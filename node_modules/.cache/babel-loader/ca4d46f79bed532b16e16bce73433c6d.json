{"ast":null,"code":"import { event, select } from 'd3-selection';\nimport { drag } from 'd3-drag';\nimport { arc, curveCatmullRom, curveLinear, line } from 'd3-shape';\nimport { dispatch } from 'd3-dispatch';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar Annotation = function () {\n  function Annotation(_ref) {\n    var _ref$x = _ref.x,\n        x = _ref$x === undefined ? 0 : _ref$x,\n        _ref$y = _ref.y,\n        y = _ref$y === undefined ? 0 : _ref$y,\n        nx = _ref.nx,\n        ny = _ref.ny,\n        _ref$dy = _ref.dy,\n        dy = _ref$dy === undefined ? 0 : _ref$dy,\n        _ref$dx = _ref.dx,\n        dx = _ref$dx === undefined ? 0 : _ref$dx,\n        _ref$color = _ref.color,\n        color = _ref$color === undefined ? \"grey\" : _ref$color,\n        data = _ref.data,\n        type = _ref.type,\n        subject = _ref.subject,\n        connector = _ref.connector,\n        note = _ref.note,\n        disable = _ref.disable,\n        id = _ref.id,\n        className = _ref.className;\n    classCallCheck(this, Annotation);\n    this._dx = nx !== undefined ? nx - x : dx;\n    this._dy = ny !== undefined ? ny - y : dy;\n    this._x = x;\n    this._y = y;\n    this._color = color;\n    this.id = id;\n    this._className = className || \"\";\n    this._type = type || \"\";\n    this.data = data;\n    this.note = note || {};\n    this.connector = connector || {};\n    this.subject = subject || {};\n    this.disable = disable || [];\n  }\n\n  createClass(Annotation, [{\n    key: \"updatePosition\",\n    value: function updatePosition() {\n      if (this.type.setPosition) {\n        this.type.setPosition();\n\n        if (this.type.subject && this.type.subject.selectAll(\":not(.handle)\").nodes().length !== 0) {\n          this.type.redrawSubject();\n        }\n      }\n    }\n  }, {\n    key: \"clearComponents\",\n    value: function clearComponents() {\n      this.type.clearComponents && this.type.clearComponents();\n    }\n  }, {\n    key: \"updateOffset\",\n    value: function updateOffset() {\n      if (this.type.setOffset) {\n        this.type.setOffset();\n\n        if (this.type.connector.selectAll(\":not(.handle)\").nodes().length !== 0) {\n          this.type.redrawConnector();\n        }\n\n        this.type.redrawNote();\n      }\n    }\n  }, {\n    key: \"className\",\n    get: function get$$1() {\n      return this._className;\n    },\n    set: function set$$1(className) {\n      this._className = className;\n      if (this.type.setClassName) this.type.setClassName();\n    }\n  }, {\n    key: \"type\",\n    get: function get$$1() {\n      return this._type;\n    },\n    set: function set$$1(type) {\n      this._type = type;\n      this.clearComponents();\n    }\n  }, {\n    key: \"x\",\n    get: function get$$1() {\n      return this._x;\n    },\n    set: function set$$1(x) {\n      this._x = x;\n      this.updatePosition();\n    }\n  }, {\n    key: \"y\",\n    get: function get$$1() {\n      return this._y;\n    },\n    set: function set$$1(y) {\n      this._y = y;\n      this.updatePosition();\n    }\n  }, {\n    key: \"color\",\n    get: function get$$1() {\n      return this._color;\n    },\n    set: function set$$1(color) {\n      this._color = color;\n      this.updatePosition();\n    }\n  }, {\n    key: \"dx\",\n    get: function get$$1() {\n      return this._dx;\n    },\n    set: function set$$1(dx) {\n      this._dx = dx;\n      this.updateOffset();\n    }\n  }, {\n    key: \"dy\",\n    get: function get$$1() {\n      return this._dy;\n    },\n    set: function set$$1(dy) {\n      this._dy = dy;\n      this.updateOffset();\n    }\n  }, {\n    key: \"nx\",\n    set: function set$$1(nx) {\n      this._dx = nx - this._x;\n      this.updateOffset();\n    }\n  }, {\n    key: \"ny\",\n    set: function set$$1(ny) {\n      this._dy = ny - this._y;\n      this.updateOffset();\n    }\n  }, {\n    key: \"offset\",\n    get: function get$$1() {\n      return {\n        x: this._dx,\n        y: this._dy\n      };\n    },\n    set: function set$$1(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y;\n      this._dx = x;\n      this._dy = y;\n      this.updateOffset();\n    }\n  }, {\n    key: \"position\",\n    get: function get$$1() {\n      return {\n        x: this._x,\n        y: this._y\n      };\n    },\n    set: function set$$1(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y;\n      this._x = x;\n      this._y = y;\n      this.updatePosition();\n    }\n  }, {\n    key: \"translation\",\n    get: function get$$1() {\n      return {\n        x: this._x + this._dx,\n        y: this._y + this._dy\n      };\n    }\n  }, {\n    key: \"json\",\n    get: function get$$1() {\n      var json = {\n        x: this._x,\n        y: this._y,\n        dx: this._dx,\n        dy: this._dy\n      };\n      if (this.data && Object.keys(this.data).length > 0) json.data = this.data;\n      if (this.type) json.type = this.type;\n      if (this._className) json.className = this._className;\n      if (Object.keys(this.connector).length > 0) json.connector = this.connector;\n      if (Object.keys(this.subject).length > 0) json.subject = this.subject;\n      if (Object.keys(this.note).length > 0) json.note = this.note;\n      return json;\n    }\n  }]);\n  return Annotation;\n}();\n\nvar AnnotationCollection = function () {\n  function AnnotationCollection(_ref) {\n    var annotations = _ref.annotations,\n        accessors = _ref.accessors,\n        accessorsInverse = _ref.accessorsInverse;\n    classCallCheck(this, AnnotationCollection);\n    this.accessors = accessors;\n    this.accessorsInverse = accessorsInverse;\n    this.annotations = annotations;\n  }\n\n  createClass(AnnotationCollection, [{\n    key: \"clearTypes\",\n    value: function clearTypes(newSettings) {\n      this.annotations.forEach(function (d) {\n        d.type = undefined;\n        d.subject = newSettings && newSettings.subject || d.subject;\n        d.connector = newSettings && newSettings.connector || d.connector;\n        d.note = newSettings && newSettings.note || d.note;\n      });\n    }\n  }, {\n    key: \"setPositionWithAccessors\",\n    value: function setPositionWithAccessors() {\n      var _this = this;\n\n      this.annotations.forEach(function (d) {\n        d.type.setPositionWithAccessors(_this.accessors);\n      });\n    }\n  }, {\n    key: \"editMode\",\n    value: function editMode(_editMode) {\n      this.annotations.forEach(function (a) {\n        if (a.type) {\n          a.type.editMode = _editMode;\n          a.type.updateEditMode();\n        }\n      });\n    }\n  }, {\n    key: \"updateDisable\",\n    value: function updateDisable(disable) {\n      this.annotations.forEach(function (a) {\n        a.disable = disable;\n\n        if (a.type) {\n          disable.forEach(function (d) {\n            if (a.type[d]) {\n              a.type[d].remove && a.type[d].remove();\n              a.type[d] = undefined;\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: \"updateTextWrap\",\n    value: function updateTextWrap(textWrap) {\n      this.annotations.forEach(function (a) {\n        if (a.type && a.type.updateTextWrap) {\n          a.type.updateTextWrap(textWrap);\n        }\n      });\n    }\n  }, {\n    key: \"updateText\",\n    value: function updateText() {\n      this.annotations.forEach(function (a) {\n        if (a.type && a.type.drawText) {\n          a.type.drawText();\n        }\n      });\n    }\n  }, {\n    key: \"updateNotePadding\",\n    value: function updateNotePadding(notePadding) {\n      this.annotations.forEach(function (a) {\n        if (a.type) {\n          a.type.notePadding = notePadding;\n        }\n      });\n    }\n  }, {\n    key: \"json\",\n    get: function get$$1() {\n      var _this2 = this;\n\n      return this.annotations.map(function (a) {\n        var json = a.json;\n\n        if (_this2.accessorsInverse && a.data) {\n          json.data = {};\n          Object.keys(_this2.accessorsInverse).forEach(function (k) {\n            json.data[k] = _this2.accessorsInverse[k]({\n              x: a.x,\n              y: a.y\n            }); //TODO make this feasible to map back to data for other types of subjects\n          });\n        }\n\n        return json;\n      });\n    }\n  }, {\n    key: \"noteNodes\",\n    get: function get$$1() {\n      return this.annotations.map(function (a) {\n        return _extends({}, a.type.getNoteBBoxOffset(), {\n          positionX: a.x,\n          positionY: a.y\n        });\n      });\n    } //TODO: come back and rethink if a.x and a.y are applicable in all situations\n    // get connectorNodes() {\n    //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))\n    // }\n    // get subjectNodes() {\n    //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))\n    // }\n    // get annotationNodes() {\n    //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))\n    // }\n\n  }]);\n  return AnnotationCollection;\n}();\n\nvar pointHandle = function pointHandle(_ref) {\n  var _ref$cx = _ref.cx,\n      cx = _ref$cx === undefined ? 0 : _ref$cx,\n      _ref$cy = _ref.cy,\n      cy = _ref$cy === undefined ? 0 : _ref$cy;\n  return {\n    move: {\n      x: cx,\n      y: cy\n    }\n  };\n};\n\nvar circleHandles = function circleHandles(_ref2) {\n  var _ref2$cx = _ref2.cx,\n      cx = _ref2$cx === undefined ? 0 : _ref2$cx,\n      _ref2$cy = _ref2.cy,\n      cy = _ref2$cy === undefined ? 0 : _ref2$cy,\n      r1 = _ref2.r1,\n      r2 = _ref2.r2,\n      padding = _ref2.padding;\n  var h = {\n    move: {\n      x: cx,\n      y: cy\n    }\n  };\n\n  if (r1 !== undefined) {\n    h.r1 = {\n      x: cx + r1 / Math.sqrt(2),\n      y: cy + r1 / Math.sqrt(2)\n    };\n  }\n\n  if (r2 !== undefined) {\n    h.r2 = {\n      x: cx + r2 / Math.sqrt(2),\n      y: cy + r2 / Math.sqrt(2)\n    };\n  }\n\n  if (padding !== undefined) {\n    h.padding = {\n      x: cx + r1 + padding,\n      y: cy\n    };\n  }\n\n  return h;\n}; //arc handles\n\n\nvar addHandles = function addHandles(_ref5) {\n  var group = _ref5.group,\n      handles = _ref5.handles,\n      _ref5$r = _ref5.r,\n      r = _ref5$r === undefined ? 10 : _ref5$r; //give it a group and x,y to draw handles\n  //then give it instructions on what the handles change\n\n  var h = group.selectAll(\"circle.handle\").data(handles);\n  h.enter().append(\"circle\").attr(\"class\", \"handle\").attr(\"fill\", \"grey\").attr(\"fill-opacity\", 0.1).attr(\"cursor\", \"move\").attr(\"stroke-dasharray\", 5).attr(\"stroke\", \"grey\").call(drag().container(select(\"g.annotations\").node()).on(\"start\", function (d) {\n    return d.start && d.start(d);\n  }).on(\"drag\", function (d) {\n    return d.drag && d.drag(d);\n  }).on(\"end\", function (d) {\n    return d.end && d.end(d);\n  }));\n  group.selectAll(\"circle.handle\").attr(\"cx\", function (d) {\n    return d.x;\n  }).attr(\"cy\", function (d) {\n    return d.y;\n  }).attr(\"r\", function (d) {\n    return d.r || r;\n  }).attr(\"class\", function (d) {\n    return \"handle \" + (d.className || \"\");\n  });\n  h.exit().remove();\n};\n\nvar leftRightDynamic = function leftRightDynamic(align, y) {\n  if (align === \"dynamic\" || align === \"left\" || align === \"right\") {\n    if (y < 0) {\n      align = \"top\";\n    } else {\n      align = \"bottom\";\n    }\n  }\n\n  return align;\n};\n\nvar topBottomDynamic = function topBottomDynamic(align, x) {\n  if (align === \"dynamic\" || align === \"top\" || align === \"bottom\") {\n    if (x < 0) {\n      align = \"right\";\n    } else {\n      align = \"left\";\n    }\n  }\n\n  return align;\n};\n\nvar orientationTopBottom = [\"topBottom\", \"top\", \"bottom\"];\nvar orientationLeftRight = [\"leftRight\", \"left\", \"right\"];\n\nvar noteAlignment = function (_ref) {\n  var _ref$padding = _ref.padding,\n      padding = _ref$padding === undefined ? 0 : _ref$padding,\n      _ref$bbox = _ref.bbox,\n      bbox = _ref$bbox === undefined ? {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  } : _ref$bbox,\n      align = _ref.align,\n      orientation = _ref.orientation,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === undefined ? {\n    x: 0,\n    y: 0\n  } : _ref$offset;\n  var x = -bbox.x;\n  var y = 0; //-bbox.y\n\n  if (orientationTopBottom.indexOf(orientation) !== -1) {\n    align = topBottomDynamic(align, offset.x);\n\n    if (offset.y < 0 && orientation === \"topBottom\" || orientation === \"top\") {\n      y -= bbox.height + padding;\n    } else {\n      y += padding;\n    }\n\n    if (align === \"middle\") {\n      x -= bbox.width / 2;\n    } else if (align === \"right\") {\n      x -= bbox.width;\n    }\n  } else if (orientationLeftRight.indexOf(orientation) !== -1) {\n    align = leftRightDynamic(align, offset.y);\n\n    if (offset.x < 0 && orientation === \"leftRight\" || orientation === \"left\") {\n      x -= bbox.width + padding;\n    } else {\n      x += padding;\n    }\n\n    if (align === \"middle\") {\n      y -= bbox.height / 2;\n    } else if (align === \"top\") {\n      y -= bbox.height;\n    }\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar lineBuilder = function lineBuilder(_ref) {\n  var data = _ref.data,\n      _ref$curve = _ref.curve,\n      curve = _ref$curve === undefined ? curveLinear : _ref$curve,\n      canvasContext = _ref.canvasContext,\n      className = _ref.className,\n      classID = _ref.classID;\n  var lineGen = line().curve(curve);\n  var builder = {\n    type: 'path',\n    className: className,\n    classID: classID,\n    data: data\n  };\n\n  if (canvasContext) {\n    lineGen.context(canvasContext);\n    builder.pathMethods = lineGen;\n  } else {\n    builder.attrs = {\n      d: lineGen(data)\n    };\n  }\n\n  return builder;\n};\n\nvar arcBuilder = function arcBuilder(_ref2) {\n  var data = _ref2.data,\n      canvasContext = _ref2.canvasContext,\n      className = _ref2.className,\n      classID = _ref2.classID;\n  var builder = {\n    type: 'path',\n    className: className,\n    classID: classID,\n    data: data\n  };\n  var arcShape = arc().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);\n\n  if (canvasContext) {\n    arcShape.context(canvasContext);\n    builder.pathMethods = lineGen;\n  } else {\n    builder.attrs = {\n      d: arcShape()\n    };\n  }\n\n  return builder;\n};\n\nvar noteVertical = function (_ref) {\n  var align = _ref.align,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      bbox = _ref.bbox,\n      offset = _ref.offset;\n  align = leftRightDynamic(align, offset.y);\n\n  if (align === \"top\") {\n    y -= bbox.height;\n  } else if (align === \"middle\") {\n    y -= bbox.height / 2;\n  }\n\n  var data = [[x, y], [x, y + bbox.height]];\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: \"note-line\"\n    })]\n  };\n};\n\nvar noteHorizontal = function (_ref) {\n  var align = _ref.align,\n      _ref$x = _ref.x,\n      x = _ref$x === undefined ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === undefined ? 0 : _ref$y,\n      offset = _ref.offset,\n      bbox = _ref.bbox;\n  align = topBottomDynamic(align, offset.x);\n\n  if (align === \"right\") {\n    x -= bbox.width;\n  } else if (align === \"middle\") {\n    x -= bbox.width / 2;\n  }\n\n  var data = [[x, y], [x + bbox.width, y]];\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: \"note-line\"\n    })]\n  };\n};\n\nvar lineSetup = function lineSetup(_ref) {\n  var type = _ref.type,\n      subjectType = _ref.subjectType;\n  var annotation = type.annotation;\n  var offset = annotation.position;\n  var x1 = annotation.x - offset.x,\n      x2 = x1 + annotation.dx,\n      y1 = annotation.y - offset.y,\n      y2 = y1 + annotation.dy;\n  var subjectData = annotation.subject;\n\n  if (subjectType === \"circle\" && (subjectData.outerRadius || subjectData.radius)) {\n    var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    var angle = Math.asin(-y2 / h);\n    var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);\n    x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);\n    y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);\n  }\n\n  if (subjectType === \"rect\") {\n    var width = subjectData.width,\n        height = subjectData.height;\n\n    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {\n      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;\n    }\n\n    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {\n      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;\n    }\n\n    if (x1 === width / 2 && y1 === height / 2) {\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  return [[x1, y1], [x2, y2]];\n};\n\nvar connectorLine = function (connectorData) {\n  var data = lineSetup(connectorData);\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: \"connector\"\n    })]\n  };\n};\n\nvar connectorElbow = function (_ref) {\n  var type = _ref.type,\n      subjectType = _ref.subjectType;\n  var annotation = type.annotation;\n  var offset = annotation.position;\n  var x1 = annotation.x - offset.x,\n      x2 = x1 + annotation.dx,\n      y1 = annotation.y - offset.y,\n      y2 = y1 + annotation.dy;\n  var subjectData = annotation.subject;\n\n  if (subjectType === \"rect\") {\n    var width = subjectData.width,\n        height = subjectData.height;\n\n    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {\n      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width / 2;else x1 = width;\n    }\n\n    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {\n      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height / 2;else y1 = height;\n    }\n\n    if (x1 === width / 2 && y1 === height / 2) {\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n\n  var data = [[x1, y1], [x2, y2]];\n  var diffY = y2 - y1;\n  var diffX = x2 - x1;\n  var xe = x2;\n  var ye = y2;\n  var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;\n\n  if (Math.abs(diffX) < Math.abs(diffY)) {\n    xe = x2;\n    ye = y1 + diffX * opposite;\n  } else {\n    ye = y2;\n    xe = x1 + diffY * opposite;\n  }\n\n  if (subjectType === \"circle\" && (subjectData.outerRadius || subjectData.radius)) {\n    var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);\n    var length = r / Math.sqrt(2);\n\n    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {\n      x1 = length * (x2 < 0 ? -1 : 1);\n      y1 = length * (y2 < 0 ? -1 : 1);\n      data = [[x1, y1], [xe, ye], [x2, y2]];\n    } else if (Math.abs(diffX) > Math.abs(diffY)) {\n      var angle = Math.asin(-y2 / r);\n      x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);\n      data = [[x1, y2], [x2, y2]];\n    } else {\n      var _angle = Math.acos(x2 / r);\n\n      y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);\n      data = [[x2, y1], [x2, y2]];\n    }\n  } else {\n    data = [[x1, y1], [xe, ye], [x2, y2]];\n  }\n\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: \"connector\"\n    })]\n  };\n};\n\nvar connectorCurve = function (_ref) {\n  var type = _ref.type,\n      connectorData = _ref.connectorData,\n      subjectType = _ref.subjectType;\n\n  if (!connectorData) {\n    connectorData = {};\n  }\n\n  if (!connectorData.points || typeof connectorData.points === \"number\") {\n    connectorData.points = createPoints(type.annotation.offset, connectorData.points);\n  }\n\n  if (!connectorData.curve) {\n    connectorData.curve = curveCatmullRom;\n  }\n\n  var handles = [];\n\n  if (type.editMode) {\n    var cHandles = connectorData.points.map(function (c, i) {\n      return _extends({}, pointHandle({\n        cx: c[0],\n        cy: c[1]\n      }), {\n        index: i\n      });\n    });\n\n    var updatePoint = function updatePoint(index) {\n      connectorData.points[index][0] += event.dx;\n      connectorData.points[index][1] += event.dy;\n      type.redrawConnector();\n    };\n\n    handles = type.mapHandles(cHandles.map(function (h) {\n      return _extends({}, h.move, {\n        drag: updatePoint.bind(type, h.index)\n      });\n    }));\n  }\n\n  var data = lineSetup({\n    type: type,\n    subjectType: subjectType\n  });\n  data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);\n  var components = [lineBuilder({\n    data: data,\n    curve: connectorData.curve,\n    className: \"connector\"\n  })];\n  return {\n    components: components,\n    handles: handles\n  };\n};\n\nvar createPoints = function createPoints(offset) {\n  var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  var diff = {\n    x: offset.x / (anchors + 1),\n    y: offset.y / (anchors + 1)\n  };\n  var p = [];\n  var i = 1;\n\n  for (; i <= anchors; i++) {\n    p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);\n  }\n\n  return p;\n};\n\nvar connectorArrow = function (_ref) {\n  var annotation = _ref.annotation,\n      start = _ref.start,\n      end = _ref.end,\n      _ref$scale = _ref.scale,\n      scale = _ref$scale === undefined ? 1 : _ref$scale;\n  var offset = annotation.position;\n\n  if (!start) {\n    start = [annotation.dx, annotation.dy];\n  } else {\n    start = [-end[0] + start[0], -end[1] + start[1]];\n  }\n\n  if (!end) {\n    end = [annotation.x - offset.x, annotation.y - offset.y];\n  }\n\n  var x1 = end[0],\n      y1 = end[1];\n  var dx = start[0];\n  var dy = start[1];\n  var size = 10 * scale;\n  var angleOffset = 16 / 180 * Math.PI;\n  var angle = Math.atan(dy / dx);\n\n  if (dx < 0) {\n    angle += Math.PI;\n  }\n\n  var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]]; //TODO add in reverse\n  // if (canvasContext.arrowReverse){\n  //   data = [[x1, y1],\n  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],\n  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],\n  //   [x1, y1]\n  //   ]\n  // } else {\n  //   data = [[x1, y1],\n  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],\n  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],\n  //   [x1, y1]\n  //   ]\n  // }\n\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: \"connector-end connector-arrow\",\n      classID: \"connector-end\"\n    })]\n  };\n};\n\nvar connectorDot = function (_ref) {\n  var line$$1 = _ref.line,\n      _ref$scale = _ref.scale,\n      scale = _ref$scale === undefined ? 1 : _ref$scale;\n  var dot = arcBuilder({\n    className: \"connector-end connector-dot\",\n    classID: \"connector-end\",\n    data: {\n      radius: 3 * Math.sqrt(scale)\n    }\n  });\n  dot.attrs.transform = \"translate(\" + line$$1.data[0][0] + \", \" + line$$1.data[0][1] + \")\";\n  return {\n    components: [dot]\n  };\n};\n\nvar subjectCircle = function (_ref) {\n  var subjectData = _ref.subjectData,\n      type = _ref.type;\n\n  if (!subjectData.radius && !subjectData.outerRadius) {\n    subjectData.radius = 20;\n  }\n\n  var handles = [];\n  var c = arcBuilder({\n    data: subjectData,\n    className: \"subject\"\n  });\n\n  if (type.editMode) {\n    var h = circleHandles({\n      r1: c.data.outerRadius || c.data.radius,\n      r2: c.data.innerRadius,\n      padding: subjectData.radiusPadding\n    });\n\n    var updateRadius = function updateRadius(attr) {\n      var r = subjectData[attr] + event.dx * Math.sqrt(2);\n      subjectData[attr] = r;\n      type.redrawSubject();\n      type.redrawConnector();\n    };\n\n    var cHandles = [_extends({}, h.r1, {\n      drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? \"outerRadius\" : \"radius\")\n    })];\n\n    if (subjectData.innerRadius) {\n      cHandles.push(_extends({}, h.r2, {\n        drag: updateRadius.bind(type, \"innerRadius\")\n      }));\n    }\n\n    handles = type.mapHandles(cHandles);\n  }\n\n  c.attrs[\"fill-opacity\"] = 0;\n  return {\n    components: [c],\n    handles: handles\n  };\n};\n\nvar subjectRect = function (_ref) {\n  var subjectData = _ref.subjectData,\n      type = _ref.type;\n\n  if (!subjectData.width) {\n    subjectData.width = 100;\n  }\n\n  if (!subjectData.height) {\n    subjectData.height = 100;\n  }\n\n  var handles = [];\n  var width = subjectData.width,\n      height = subjectData.height;\n  var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];\n  var rect = lineBuilder({\n    data: data,\n    className: \"subject\"\n  });\n\n  if (type.editMode) {\n    var updateWidth = function updateWidth() {\n      subjectData.width = event.x;\n      type.redrawSubject();\n      type.redrawConnector();\n    };\n\n    var updateHeight = function updateHeight() {\n      subjectData.height = event.y;\n      type.redrawSubject();\n      type.redrawConnector();\n    };\n\n    var rHandles = [{\n      x: width,\n      y: height / 2,\n      drag: updateWidth.bind(type)\n    }, {\n      x: width / 2,\n      y: height,\n      drag: updateHeight.bind(type)\n    }];\n    handles = type.mapHandles(rHandles);\n  }\n\n  rect.attrs[\"fill-opacity\"] = 0.1;\n  return {\n    components: [rect],\n    handles: handles\n  };\n};\n\nvar subjectThreshold = function (_ref) {\n  var subjectData = _ref.subjectData,\n      type = _ref.type;\n  var offset = type.annotation.position;\n  var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,\n      x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,\n      y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,\n      y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;\n  var data = [[x1, y1], [x2, y2]];\n  return {\n    components: [lineBuilder({\n      data: data,\n      className: 'subject'\n    })]\n  };\n};\n\nvar subjectBadge = function (_ref) {\n  var _ref$subjectData = _ref.subjectData,\n      subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData,\n      _ref$type = _ref.type,\n      type = _ref$type === undefined ? {} : _ref$type;\n  var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var typeSettings = type.typeSettings && type.typeSettings.subject;\n\n  if (!subjectData.radius) {\n    if (typeSettings && typeSettings.radius) {\n      subjectData.radius = typeSettings.radius;\n    } else {\n      subjectData.radius = 14;\n    }\n  }\n\n  if (!subjectData.x) {\n    if (typeSettings && typeSettings.x) {\n      subjectData.x = typeSettings.x;\n    }\n  }\n\n  if (!subjectData.y) {\n    if (typeSettings && typeSettings.y) {\n      subjectData.y = typeSettings.y;\n    }\n  }\n\n  var handles = [];\n  var components = [];\n  var radius = subjectData.radius;\n  var innerRadius = radius * 0.7;\n  var x = 0;\n  var y = 0;\n  var notCornerOffset = Math.sqrt(2) * radius;\n  var placement = {\n    xleftcorner: -radius,\n    xrightcorner: radius,\n    ytopcorner: -radius,\n    ybottomcorner: radius,\n    xleft: -notCornerOffset,\n    xright: notCornerOffset,\n    ytop: -notCornerOffset,\n    ybottom: notCornerOffset\n  };\n\n  if (subjectData.x && !subjectData.y) {\n    x = placement[\"x\" + subjectData.x];\n  } else if (subjectData.y && !subjectData.x) {\n    y = placement[\"y\" + subjectData.y];\n  } else if (subjectData.x && subjectData.y) {\n    x = placement[\"x\" + subjectData.x + \"corner\"];\n    y = placement[\"y\" + subjectData.y + \"corner\"];\n  }\n\n  var transform = \"translate(\" + x + \", \" + y + \")\";\n  var circlebg = arcBuilder({\n    className: \"subject\",\n    data: {\n      radius: radius\n    }\n  });\n  circlebg.attrs.transform = transform;\n  circlebg.attrs.fill = annotation.color;\n  circlebg.attrs[\"stroke-linecap\"] = \"round\";\n  circlebg.attrs[\"stroke-width\"] = \"3px\";\n  var circle = arcBuilder({\n    className: \"subject-ring\",\n    data: {\n      outerRadius: radius,\n      innerRadius: innerRadius\n    }\n  });\n  circle.attrs.transform = transform; // circle.attrs.fill = annotation.color\n\n  circle.attrs[\"stroke-width\"] = \"3px\";\n  circle.attrs.fill = \"white\";\n  var pointer = void 0;\n\n  if (x && y || !x && !y) {\n    pointer = lineBuilder({\n      className: \"subject-pointer\",\n      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]\n    });\n  } else if (x || y) {\n    var notCornerPointerXY = function notCornerPointerXY(v) {\n      var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);\n    };\n\n    pointer = lineBuilder({\n      className: \"subject-pointer\",\n      data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]\n    });\n  }\n\n  if (pointer) {\n    pointer.attrs.fill = annotation.color;\n    pointer.attrs[\"stroke-linecap\"] = \"round\";\n    pointer.attrs[\"stroke-width\"] = \"3px\";\n    components.push(pointer);\n  }\n\n  if (type.editMode) {\n    var dragBadge = function dragBadge() {\n      subjectData.x = event.x < -radius * 2 ? \"left\" : event.x > radius * 2 ? \"right\" : undefined;\n      subjectData.y = event.y < -radius * 2 ? \"top\" : event.y > radius * 2 ? \"bottom\" : undefined;\n      type.redrawSubject();\n    };\n\n    var bHandles = {\n      x: x * 2,\n      y: y * 2,\n      drag: dragBadge.bind(type)\n    };\n\n    if (!bHandles.x && !bHandles.y) {\n      bHandles.y = -radius;\n    }\n\n    handles = type.mapHandles([bHandles]);\n  }\n\n  var text = void 0;\n\n  if (subjectData.text) {\n    text = {\n      type: \"text\",\n      className: \"badge-text\",\n      attrs: {\n        fill: \"white\",\n        stroke: \"none\",\n        \"font-size\": \".7em\",\n        text: subjectData.text,\n        \"text-anchor\": \"middle\",\n        dy: \".25em\",\n        x: x,\n        y: y\n      }\n    };\n  }\n\n  components.push(circlebg);\n  components.push(circle);\n  components.push(text);\n  return {\n    components: components,\n    handles: handles\n  };\n}; //Note options\n//Connector options\n//Subject options\n\n\nvar Type = function () {\n  function Type(_ref) {\n    var a = _ref.a,\n        annotation = _ref.annotation,\n        editMode = _ref.editMode,\n        dispatcher = _ref.dispatcher,\n        notePadding = _ref.notePadding,\n        accessors = _ref.accessors;\n    classCallCheck(this, Type);\n    this.a = a;\n    this.note = annotation.disable.indexOf(\"note\") === -1 && a.select(\"g.annotation-note\");\n    this.noteContent = this.note && a.select(\"g.annotation-note-content\");\n    this.connector = annotation.disable.indexOf(\"connector\") === -1 && a.select(\"g.annotation-connector\");\n    this.subject = annotation.disable.indexOf(\"subject\") === -1 && a.select(\"g.annotation-subject\");\n    this.dispatcher = dispatcher;\n\n    if (dispatcher) {\n      var handler = addHandlers.bind(null, dispatcher, annotation);\n      handler({\n        component: this.note,\n        name: \"note\"\n      });\n      handler({\n        component: this.connector,\n        name: \"connector\"\n      });\n      handler({\n        component: this.subject,\n        name: \"subject\"\n      });\n    }\n\n    this.annotation = annotation;\n    this.editMode = annotation.editMode || editMode;\n    this.notePadding = notePadding !== undefined ? notePadding : 3;\n    this.offsetCornerX = 0;\n    this.offsetCornerY = 0;\n\n    if (accessors && annotation.data) {\n      this.init(accessors);\n    }\n  }\n\n  createClass(Type, [{\n    key: \"init\",\n    value: function init(accessors) {\n      if (!this.annotation.x) {\n        this.mapX(accessors);\n      }\n\n      if (!this.annotation.y) {\n        this.mapY(accessors);\n      }\n    }\n  }, {\n    key: \"mapY\",\n    value: function mapY(accessors) {\n      if (accessors.y) {\n        this.annotation.y = accessors.y(this.annotation.data);\n      }\n    }\n  }, {\n    key: \"mapX\",\n    value: function mapX(accessors) {\n      if (accessors.x) {\n        this.annotation.x = accessors.x(this.annotation.data);\n      }\n    }\n  }, {\n    key: \"updateEditMode\",\n    value: function updateEditMode() {\n      this.a.selectAll(\"circle.handle\").remove();\n    }\n  }, {\n    key: \"drawOnSVG\",\n    value: function drawOnSVG(component, builders) {\n      var _this = this;\n\n      if (!Array.isArray(builders)) {\n        builders = [builders];\n      }\n\n      builders.filter(function (b) {\n        return b;\n      }).forEach(function (_ref2) {\n        var type = _ref2.type,\n            className = _ref2.className,\n            attrs = _ref2.attrs,\n            handles = _ref2.handles,\n            classID = _ref2.classID;\n\n        if (type === \"handle\") {\n          addHandles({\n            group: component,\n            r: attrs && attrs.r,\n            handles: handles\n          });\n        } else {\n          newWithClass(component, [_this.annotation], type, className, classID);\n          var el = component.select(type + \".\" + (classID || className));\n          var addAttrs = Object.keys(attrs);\n          var removeAttrs = [];\n          var currentAttrs = el.node().attributes;\n\n          for (var i = currentAttrs.length - 1; i >= 0; i--) {\n            var name = currentAttrs[i].name;\n            if (addAttrs.indexOf(name) === -1 && name !== \"class\") removeAttrs.push(name);\n          }\n\n          addAttrs.forEach(function (attr) {\n            if (attr === \"text\") {\n              el.text(attrs[attr]);\n            } else {\n              el.attr(attr, attrs[attr]);\n            }\n          });\n          removeAttrs.forEach(function (attr) {\n            return el.attr(attr, null);\n          });\n        }\n      });\n    } //TODO: how to extend this to a drawOnCanvas mode?\n\n  }, {\n    key: \"getNoteBBox\",\n    value: function getNoteBBox() {\n      return bboxWithoutHandles(this.note, \".annotation-note-content text\");\n    }\n  }, {\n    key: \"getNoteBBoxOffset\",\n    value: function getNoteBBoxOffset() {\n      var bbox = bboxWithoutHandles(this.note, \".annotation-note-content\");\n      var transform = this.noteContent.attr(\"transform\").split(/\\(|\\,|\\)/g);\n      bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;\n      bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;\n      bbox.offsetX = this.annotation.dx;\n      bbox.offsetY = this.annotation.dy;\n      return bbox;\n    }\n  }, {\n    key: \"drawSubject\",\n    value: function drawSubject() {\n      var _this2 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var subjectData = this.annotation.subject;\n      var type = context.type;\n      var subjectParams = {\n        type: this,\n        subjectData: subjectData\n      };\n      var subject = {};\n      if (type === \"circle\") subject = subjectCircle(subjectParams);else if (type === \"rect\") subject = subjectRect(subjectParams);else if (type === \"threshold\") subject = subjectThreshold(subjectParams);else if (type === \"badge\") subject = subjectBadge(subjectParams, this.annotation);\n      var _subject = subject,\n          _subject$components = _subject.components,\n          components = _subject$components === undefined ? [] : _subject$components,\n          _subject$handles = _subject.handles,\n          handles = _subject$handles === undefined ? [] : _subject$handles;\n      components.forEach(function (c) {\n        if (c && c.attrs && !c.attrs.stroke) {\n          c.attrs.stroke = _this2.annotation.color;\n        }\n      });\n\n      if (this.editMode) {\n        handles = handles.concat(this.mapHandles([{\n          drag: this.dragSubject.bind(this)\n        }]));\n        components.push({\n          type: \"handle\",\n          handles: handles\n        });\n      }\n\n      return components;\n    }\n  }, {\n    key: \"drawConnector\",\n    value: function drawConnector() {\n      var _this3 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var connectorData = this.annotation.connector;\n      var type = connectorData.type || context.type;\n      var connectorParams = {\n        type: this,\n        connectorData: connectorData\n      };\n      connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;\n      var connector = {};\n      if (type === \"curve\") connector = connectorCurve(connectorParams);else if (type === \"elbow\") connector = connectorElbow(connectorParams);else connector = connectorLine(connectorParams);\n      var _connector = connector,\n          _connector$components = _connector.components,\n          components = _connector$components === undefined ? [] : _connector$components,\n          _connector$handles = _connector.handles,\n          handles = _connector$handles === undefined ? [] : _connector$handles;\n      var line$$1 = components[0]; //TODO: genericize this into fill t/f stroke t/f\n\n      if (line$$1) {\n        line$$1.attrs.stroke = this.annotation.color;\n        line$$1.attrs.fill = \"none\";\n      }\n\n      var endType = connectorData.end || context.end;\n      var end = {};\n\n      if (endType === \"arrow\") {\n        var s = line$$1.data[1];\n        var e = line$$1.data[0];\n        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));\n\n        if (distance < 5 && line$$1.data[2]) {\n          s = line$$1.data[2];\n        }\n\n        end = connectorArrow({\n          annotation: this.annotation,\n          start: s,\n          end: e,\n          scale: connectorData.endScale\n        });\n      } else if (endType === \"dot\") {\n        end = connectorDot({\n          line: line$$1,\n          scale: connectorData.endScale\n        });\n      } else if (!endType || endType === \"none\") {\n        this.connector && this.connector.select(\".connector-end\").remove();\n      }\n\n      if (end.components) {\n        end.components.forEach(function (c) {\n          c.attrs.fill = _this3.annotation.color;\n          c.attrs.stroke = _this3.annotation.color;\n        });\n        components = components.concat(end.components);\n      }\n\n      if (this.editMode) {\n        if (handles.length !== 0) components.push({\n          type: \"handle\",\n          handles: handles\n        });\n      }\n\n      return components;\n    }\n  }, {\n    key: \"drawNote\",\n    value: function drawNote() {\n      var _this4 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var noteData = this.annotation.note;\n      var align = noteData.align || context.align || \"dynamic\";\n      var noteParams = {\n        bbox: context.bbox,\n        align: align,\n        offset: this.annotation.offset\n      };\n      var lineType = noteData.lineType || context.lineType;\n      var note = {};\n      if (lineType === \"vertical\") note = noteVertical(noteParams);else if (lineType === \"horizontal\") note = noteHorizontal(noteParams);\n      var _note = note,\n          _note$components = _note.components,\n          components = _note$components === undefined ? [] : _note$components,\n          _note$handles = _note.handles,\n          handles = _note$handles === undefined ? [] : _note$handles;\n      components.forEach(function (c) {\n        c.attrs.stroke = _this4.annotation.color;\n      });\n\n      if (this.editMode) {\n        handles = this.mapHandles([{\n          x: 0,\n          y: 0,\n          drag: this.dragNote.bind(this)\n        }]);\n        components.push({\n          type: \"handle\",\n          handles: handles\n        });\n        var dragging = this.dragNote.bind(this),\n            start = this.dragstarted.bind(this),\n            end = this.dragended.bind(this);\n        this.note.call(drag().container(select(\"g.annotations\").node()).on(\"start\", function (d) {\n          return start(d);\n        }).on(\"drag\", function (d) {\n          return dragging(d);\n        }).on(\"end\", function (d) {\n          return end(d);\n        }));\n      } else {\n        this.note.on(\"mousedown.drag\", null);\n      }\n\n      return components;\n    }\n  }, {\n    key: \"drawNoteContent\",\n    value: function drawNoteContent(context) {\n      var noteData = this.annotation.note;\n      var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;\n      var orientation = noteData.orientation || context.orientation || \"topBottom\";\n      var lineType = noteData.lineType || context.lineType;\n      var align = noteData.align || context.align || \"dynamic\";\n      if (lineType === \"vertical\") orientation = \"leftRight\";else if (lineType === \"horizontal\") orientation = \"topBottom\";\n      var noteParams = {\n        padding: padding,\n        bbox: context.bbox,\n        offset: this.annotation.offset,\n        orientation: orientation,\n        align: align\n      };\n\n      var _noteAlignment = noteAlignment(noteParams),\n          x = _noteAlignment.x,\n          y = _noteAlignment.y;\n\n      this.offsetCornerX = x + this.annotation.dx;\n      this.offsetCornerY = y + this.annotation.dy;\n      this.note && this.noteContent.attr(\"transform\", \"translate(\" + x + \", \" + y + \")\");\n      return [];\n    }\n  }, {\n    key: \"drawOnScreen\",\n    value: function drawOnScreen(component, drawFunction) {\n      return this.drawOnSVG(component, drawFunction);\n    }\n  }, {\n    key: \"redrawSubject\",\n    value: function redrawSubject() {\n      this.subject && this.drawOnScreen(this.subject, this.drawSubject());\n    }\n  }, {\n    key: \"redrawConnector\",\n    value: function redrawConnector() {\n      this.connector && this.drawOnScreen(this.connector, this.drawConnector());\n    }\n  }, {\n    key: \"redrawNote\",\n    value: function redrawNote() {\n      var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();\n      this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({\n        bbox: bbox\n      }));\n      this.note && this.drawOnScreen(this.note, this.drawNote({\n        bbox: bbox\n      }));\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition() {\n      var position = this.annotation.position;\n      this.a.attr(\"transform\", \"translate(\" + position.x + \", \" + position.y + \")\");\n    }\n  }, {\n    key: \"clearComponents\",\n    value: function clearComponents() {\n      this.subject && this.subject.select(\"*\").remove();\n      this.connector && this.connector.select(\"*\").remove(); // this.note && this.note.select(\"*\").remove()\n    }\n  }, {\n    key: \"setOffset\",\n    value: function setOffset() {\n      if (this.note) {\n        var offset = this.annotation.offset;\n        this.note.attr(\"transform\", \"translate(\" + offset.x + \", \" + offset.y + \")\");\n      }\n    }\n  }, {\n    key: \"setPositionWithAccessors\",\n    value: function setPositionWithAccessors(accessors) {\n      if (accessors && this.annotation.data) {\n        this.mapX(accessors);\n        this.mapY(accessors);\n      }\n\n      this.setPosition();\n    }\n  }, {\n    key: \"setClassName\",\n    value: function setClassName() {\n      this.a.attr(\"class\", \"annotation \" + (this.className && this.className()) + \" \" + (this.editMode ? \"editable\" : \"\") + \" \" + (this.annotation.className || \"\"));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.setClassName();\n      this.setPosition();\n      this.setOffset();\n      this.redrawSubject();\n      this.redrawConnector();\n      this.redrawNote();\n    }\n  }, {\n    key: \"dragstarted\",\n    value: function dragstarted() {\n      event.sourceEvent.stopPropagation();\n      this.dispatcher && this.dispatcher.call(\"dragstart\", this.a, this.annotation);\n      this.a.classed(\"dragging\", true);\n      this.a.selectAll(\"circle.handle\").style(\"pointer-events\", \"none\");\n    }\n  }, {\n    key: \"dragended\",\n    value: function dragended() {\n      this.dispatcher && this.dispatcher.call(\"dragend\", this.a, this.annotation);\n      this.a.classed(\"dragging\", false);\n      this.a.selectAll(\"circle.handle\").style(\"pointer-events\", \"all\");\n    }\n  }, {\n    key: \"dragSubject\",\n    value: function dragSubject() {\n      var position = this.annotation.position;\n      position.x += event.dx;\n      position.y += event.dy;\n      this.annotation.position = position;\n    }\n  }, {\n    key: \"dragNote\",\n    value: function dragNote() {\n      var offset = this.annotation.offset;\n      offset.x += event.dx;\n      offset.y += event.dy;\n      this.annotation.offset = offset;\n    }\n  }, {\n    key: \"mapHandles\",\n    value: function mapHandles(handles) {\n      var _this5 = this;\n\n      return handles.map(function (h) {\n        return _extends({}, h, {\n          start: _this5.dragstarted.bind(_this5),\n          end: _this5.dragended.bind(_this5)\n        });\n      });\n    }\n  }]);\n  return Type;\n}();\n\nvar customType = function customType(initialType, typeSettings, _init) {\n  return function (_initialType) {\n    inherits(customType, _initialType);\n\n    function customType(settings) {\n      classCallCheck(this, customType);\n\n      var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));\n\n      _this6.typeSettings = typeSettings;\n\n      if (typeSettings.disable) {\n        typeSettings.disable.forEach(function (d) {\n          _this6[d] && _this6[d].remove();\n          _this6[d] = undefined;\n\n          if (d === \"note\") {\n            _this6.noteContent = undefined;\n          }\n        });\n      }\n\n      return _this6;\n    }\n\n    createClass(customType, [{\n      key: \"className\",\n      value: function className() {\n        return \"\" + (typeSettings.className || get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"className\", this) && get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"className\", this).call(this) || \"\");\n      }\n    }, {\n      key: \"drawSubject\",\n      value: function drawSubject(context) {\n        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);\n        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"drawSubject\", this).call(this, _extends({}, context, this.typeSettings.subject));\n      }\n    }, {\n      key: \"drawConnector\",\n      value: function drawConnector(context) {\n        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);\n        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"drawConnector\", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));\n      }\n    }, {\n      key: \"drawNote\",\n      value: function drawNote(context) {\n        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);\n        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"drawNote\", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));\n      }\n    }, {\n      key: \"drawNoteContent\",\n      value: function drawNoteContent(context) {\n        return get(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), \"drawNoteContent\", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));\n      }\n    }], [{\n      key: \"init\",\n      value: function init(annotation, accessors) {\n        get(customType.__proto__ || Object.getPrototypeOf(customType), \"init\", this).call(this, annotation, accessors);\n\n        if (_init) {\n          annotation = _init(annotation, accessors);\n        }\n\n        return annotation;\n      }\n    }]);\n    return customType;\n  }(initialType);\n};\n\nvar d3NoteText = function (_Type) {\n  inherits(d3NoteText, _Type);\n\n  function d3NoteText(params) {\n    classCallCheck(this, d3NoteText);\n\n    var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));\n\n    _this7.textWrap = params.textWrap || 120;\n\n    _this7.drawText();\n\n    return _this7;\n  }\n\n  createClass(d3NoteText, [{\n    key: \"updateTextWrap\",\n    value: function updateTextWrap(textWrap) {\n      this.textWrap = textWrap;\n      this.drawText();\n    } //TODO: add update text functionality\n\n  }, {\n    key: \"drawText\",\n    value: function drawText() {\n      if (this.note) {\n        newWithClass(this.note, [this.annotation], \"g\", \"annotation-note-content\");\n        var noteContent = this.note.select(\"g.annotation-note-content\");\n        newWithClass(noteContent, [this.annotation], \"rect\", \"annotation-note-bg\");\n        newWithClass(noteContent, [this.annotation], \"text\", \"annotation-note-label\");\n        newWithClass(noteContent, [this.annotation], \"text\", \"annotation-note-title\");\n        var titleBBox = {\n          height: 0\n        };\n        var label = this.a.select(\"text.annotation-note-label\");\n        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;\n        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;\n        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;\n        var bgPaddingFinal = {\n          top: 0,\n          bottom: 0,\n          left: 0,\n          right: 0\n        };\n\n        if (typeof bgPadding === \"number\") {\n          bgPaddingFinal = {\n            top: bgPadding,\n            bottom: bgPadding,\n            left: bgPadding,\n            right: bgPadding\n          };\n        } else if (bgPadding && (typeof bgPadding === \"undefined\" ? \"undefined\" : _typeof(bgPadding)) === \"object\") {\n          bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);\n        }\n\n        if (this.annotation.note.title) {\n          var title = this.a.select(\"text.annotation-note-title\");\n          title.text(this.annotation.note.title);\n          title.attr(\"fill\", this.annotation.color);\n          title.attr(\"font-weight\", \"bold\");\n          title.call(wrap, wrapLength, wrapSplitter);\n          titleBBox = title.node().getBBox();\n        }\n\n        label.text(this.annotation.note.label).attr(\"dx\", \"0\");\n        label.call(wrap, wrapLength, wrapSplitter);\n        label.attr(\"y\", titleBBox.height * 1.1 || 0);\n        label.attr(\"fill\", this.annotation.color);\n        var bbox = this.getNoteBBox();\n        this.a.select(\"rect.annotation-note-bg\").attr(\"width\", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr(\"height\", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr(\"x\", bbox.x - bgPaddingFinal.left).attr(\"y\", -bgPaddingFinal.top).attr(\"fill\", \"white\").attr(\"fill-opacity\", 0);\n      }\n    }\n  }]);\n  return d3NoteText;\n}(Type);\n\nvar d3Label = customType(d3NoteText, {\n  className: \"label\",\n  note: {\n    align: \"middle\"\n  }\n});\nvar d3Callout = customType(d3NoteText, {\n  className: \"callout\",\n  note: {\n    lineType: \"horizontal\"\n  }\n});\nvar d3CalloutElbow = customType(d3Callout, {\n  className: \"callout elbow\",\n  connector: {\n    type: \"elbow\"\n  }\n});\nvar d3CalloutCurve = customType(d3Callout, {\n  className: \"callout curve\",\n  connector: {\n    type: \"curve\"\n  }\n});\nvar d3Badge = customType(Type, {\n  className: \"badge\",\n  subject: {\n    type: \"badge\"\n  },\n  disable: [\"connector\", \"note\"]\n});\nvar d3CalloutCircle = customType(d3NoteText, {\n  className: \"callout circle\",\n  subject: {\n    type: \"circle\"\n  },\n  note: {\n    lineType: \"horizontal\"\n  },\n  connector: {\n    type: \"elbow\"\n  }\n});\nvar d3CalloutRect = customType(d3NoteText, {\n  className: \"callout rect\",\n  subject: {\n    type: \"rect\"\n  },\n  note: {\n    lineType: \"horizontal\"\n  },\n  connector: {\n    type: \"elbow\"\n  }\n});\n\nvar ThresholdMap = function (_d3Callout) {\n  inherits(ThresholdMap, _d3Callout);\n\n  function ThresholdMap() {\n    classCallCheck(this, ThresholdMap);\n    return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));\n  }\n\n  createClass(ThresholdMap, [{\n    key: \"mapY\",\n    value: function mapY(accessors) {\n      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), \"mapY\", this).call(this, accessors);\n      var a = this.annotation;\n\n      if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {\n        a.y = accessors.y(a.data);\n      }\n\n      if ((a.subject.x1 || a.subject.x2) && !a.x) {\n        a.x = a.subject.x1 || a.subject.x2;\n      }\n    }\n  }, {\n    key: \"mapX\",\n    value: function mapX(accessors) {\n      get(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), \"mapX\", this).call(this, accessors);\n      var a = this.annotation;\n\n      if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {\n        a.x = accessors.x(a.data);\n      }\n\n      if ((a.subject.y1 || a.subject.y2) && !a.y) {\n        a.y = a.subject.y1 || a.subject.y2;\n      }\n    }\n  }]);\n  return ThresholdMap;\n}(d3Callout);\n\nvar d3XYThreshold = customType(ThresholdMap, {\n  className: \"callout xythreshold\",\n  subject: {\n    type: \"threshold\"\n  }\n});\n\nvar newWithClass = function newWithClass(a, d, type, className, classID) {\n  var group = a.selectAll(type + \".\" + (classID || className)).data(d);\n  group.enter().append(type).merge(group).attr(\"class\", className);\n  group.exit().remove();\n  return a;\n};\n\nvar addHandlers = function addHandlers(dispatcher, annotation, _ref3) {\n  var component = _ref3.component,\n      name = _ref3.name;\n\n  if (component) {\n    component.on(\"mouseover.annotations\", function () {\n      dispatcher.call(name + \"over\", component, annotation);\n    }).on(\"mouseout.annotations\", function () {\n      return dispatcher.call(name + \"out\", component, annotation);\n    }).on(\"click.annotations\", function () {\n      return dispatcher.call(name + \"click\", component, annotation);\n    });\n  }\n}; //Text wrapping code adapted from Mike Bostock\n\n\nvar wrap = function wrap(text, width, wrapSplitter) {\n  var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;\n  text.each(function () {\n    var text = select(this),\n        words = text.text().split(wrapSplitter || /[ \\t\\r\\n]+/).reverse().filter(function (w) {\n      return w !== \"\";\n    });\n    var word = void 0,\n        line$$1 = [],\n        tspan = text.text(null).append(\"tspan\").attr(\"x\", 0).attr(\"dy\", 0.8 + \"em\");\n\n    while (word = words.pop()) {\n      line$$1.push(word);\n      tspan.text(line$$1.join(\" \"));\n\n      if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {\n        line$$1.pop();\n        tspan.text(line$$1.join(\" \"));\n        line$$1 = [word];\n        tspan = text.append(\"tspan\").attr(\"x\", 0).attr(\"dy\", lineHeight + \"em\").text(word);\n      }\n    }\n  });\n};\n\nvar bboxWithoutHandles = function bboxWithoutHandles(selection) {\n  var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \":not(.handle)\";\n\n  if (!selection) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n\n  return selection.selectAll(selector).nodes().reduce(function (p, c) {\n    var bbox = c.getBBox();\n    p.x = Math.min(p.x, bbox.x);\n    p.y = Math.min(p.y, bbox.y);\n    p.width = Math.max(p.width, bbox.width);\n    var yOffset = c && c.attributes && c.attributes.y;\n    p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);\n    return p;\n  }, {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  });\n};\n\nfunction annotation() {\n  var annotations = [],\n      collection = void 0,\n      context = void 0,\n      //TODO: add canvas functionality\n  disable = [],\n      accessors = {},\n      accessorsInverse = {},\n      editMode = false,\n      ids = void 0,\n      type = d3Callout,\n      textWrap = void 0,\n      notePadding = void 0,\n      annotationDispatcher = dispatch(\"subjectover\", \"subjectout\", \"subjectclick\", \"connectorover\", \"connectorout\", \"connectorclick\", \"noteover\", \"noteout\", \"noteclick\", \"dragend\", \"dragstart\"),\n      sel = void 0;\n\n  var annotation = function annotation(selection) {\n    sel = selection; //TODO: check to see if this is still needed\n\n    if (!editMode) {\n      selection.selectAll(\"circle.handle\").remove();\n    }\n\n    var translatedAnnotations = annotations.map(function (a) {\n      if (!a.type) {\n        a.type = type;\n      }\n\n      if (!a.disable) {\n        a.disable = disable;\n      }\n\n      return new Annotation(a);\n    });\n    collection = collection || new AnnotationCollection({\n      annotations: translatedAnnotations,\n      accessors: accessors,\n      accessorsInverse: accessorsInverse,\n      ids: ids\n    });\n    var annotationG = selection.selectAll(\"g\").data([collection]);\n    annotationG.enter().append(\"g\").attr(\"class\", \"annotations\");\n    var group = selection.select(\"g.annotations\");\n    newWithClass(group, collection.annotations, \"g\", \"annotation\");\n    var annotation = group.selectAll(\"g.annotation\");\n    annotation.each(function (d) {\n      var a = select(this);\n      a.attr(\"class\", \"annotation\");\n      newWithClass(a, [d], \"g\", \"annotation-connector\");\n      newWithClass(a, [d], \"g\", \"annotation-subject\");\n      newWithClass(a, [d], \"g\", \"annotation-note\");\n      newWithClass(a.select(\"g.annotation-note\"), [d], \"g\", \"annotation-note-content\");\n      d.type = d.type.toString() === \"[object Object]\" ? d.type : new d.type({\n        a: a,\n        annotation: d,\n        textWrap: textWrap,\n        notePadding: notePadding,\n        editMode: editMode,\n        dispatcher: annotationDispatcher,\n        accessors: accessors\n      });\n      d.type.draw();\n      d.type.drawText && d.type.drawText();\n    });\n  };\n\n  annotation.json = function () {\n    /* eslint-disable no-console */\n    console.log(\"Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.\", collection.json);\n    /* eslint-enable no-console */\n\n    window.copy(JSON.stringify(collection.json.map(function (a) {\n      delete a.type;\n      return a;\n    })));\n    return annotation;\n  };\n\n  annotation.update = function () {\n    if (annotations && collection) {\n      annotations = collection.annotations.map(function (a) {\n        a.type.draw();\n        return a;\n      });\n    }\n\n    return annotation;\n  };\n\n  annotation.updateText = function () {\n    if (collection) {\n      collection.updateText(textWrap);\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  };\n\n  annotation.updatedAccessors = function () {\n    collection.setPositionWithAccessors();\n    annotations = collection.annotations;\n    return annotation;\n  };\n\n  annotation.disable = function (_) {\n    if (!arguments.length) return disable;\n    disable = _;\n\n    if (collection) {\n      collection.updateDisable(disable);\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  };\n\n  annotation.textWrap = function (_) {\n    if (!arguments.length) return textWrap;\n    textWrap = _;\n\n    if (collection) {\n      collection.updateTextWrap(textWrap);\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  };\n\n  annotation.notePadding = function (_) {\n    if (!arguments.length) return notePadding;\n    notePadding = _;\n\n    if (collection) {\n      collection.updateNotePadding(notePadding);\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  }; //todo think of how to handle when undefined is sent\n\n\n  annotation.type = function (_, settings) {\n    if (!arguments.length) return type;\n    type = _;\n\n    if (collection) {\n      collection.annotations.map(function (a) {\n        a.type.note && a.type.note.selectAll(\"*:not(.annotation-note-content)\").remove();\n        a.type.noteContent && a.type.noteContent.selectAll(\"*\").remove();\n        a.type.subject && a.type.subject.selectAll(\"*\").remove();\n        a.type.connector && a.type.connector.selectAll(\"*\").remove();\n        a.type.typeSettings = {};\n        a.type = type;\n        a.subject = settings && settings.subject || a.subject;\n        a.connector = settings && settings.connector || a.connector;\n        a.note = settings && settings.note || a.note;\n      });\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  };\n\n  annotation.annotations = function (_) {\n    if (!arguments.length) return collection && collection.annotations || annotations;\n    annotations = _;\n\n    if (collection && collection.annotations) {\n      var rerun = annotations.some(function (d) {\n        return !d.type || d.type.toString() !== \"[object Object]\";\n      });\n\n      if (rerun) {\n        collection = null;\n        annotation(sel);\n      } else {\n        collection.annotations = annotations;\n      }\n    }\n\n    return annotation;\n  };\n\n  annotation.context = function (_) {\n    if (!arguments.length) return context;\n    context = _;\n    return annotation;\n  };\n\n  annotation.accessors = function (_) {\n    if (!arguments.length) return accessors;\n    accessors = _;\n    return annotation;\n  };\n\n  annotation.accessorsInverse = function (_) {\n    if (!arguments.length) return accessorsInverse;\n    accessorsInverse = _;\n    return annotation;\n  };\n\n  annotation.ids = function (_) {\n    if (!arguments.length) return ids;\n    ids = _;\n    return annotation;\n  };\n\n  annotation.editMode = function (_) {\n    if (!arguments.length) return editMode;\n    editMode = _;\n\n    if (sel) {\n      sel.selectAll(\"g.annotation\").classed(\"editable\", editMode);\n    }\n\n    if (collection) {\n      collection.editMode(editMode);\n      annotations = collection.annotations;\n    }\n\n    return annotation;\n  };\n\n  annotation.collection = function (_) {\n    if (!arguments.length) return collection;\n    collection = _;\n    return annotation;\n  };\n\n  annotation.on = function () {\n    var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);\n    return value === annotationDispatcher ? annotation : value;\n  };\n\n  return annotation;\n}\n\nvar index = {\n  annotation: annotation,\n  annotationTypeBase: Type,\n  annotationLabel: d3Label,\n  annotationCallout: d3Callout,\n  annotationCalloutCurve: d3CalloutCurve,\n  annotationCalloutElbow: d3CalloutElbow,\n  annotationCalloutCircle: d3CalloutCircle,\n  annotationCalloutRect: d3CalloutRect,\n  annotationXYThreshold: d3XYThreshold,\n  annotationBadge: d3Badge,\n  annotationCustomType: customType\n};\nexport { annotation, Type as annotationTypeBase, d3Label as annotationLabel, d3Callout as annotationCallout, d3CalloutCurve as annotationCalloutCurve, d3CalloutElbow as annotationCalloutElbow, d3CalloutCircle as annotationCalloutCircle, d3CalloutRect as annotationCalloutRect, d3XYThreshold as annotationXYThreshold, d3Badge as annotationBadge, customType as annotationCustomType };\nexport default index;","map":{"version":3,"sources":["src/Annotation.js","src/AnnotationCollection.js","src/Handles.js","src/Note/alignment.js","src/Builder.js","src/Note/lineType-vertical.js","src/Note/lineType-horizontal.js","src/Connector/type-line.js","src/Connector/type-elbow.js","src/Connector/type-curve.js","src/Connector/end-arrow.js","src/Connector/end-dot.js","src/Subject/circle.js","src/Subject/rect.js","src/Subject/threshold.js","src/Subject/badge.js","src/Types-d3.js","src/Adapter-d3.js","index.js"],"names":["Annotation","x","y","nx","ny","dy","dx","color","data","type","subject","connector","note","disable","id","className","_dy","json","Object","AnnotationCollection","annotations","accessors","accessorsInverse","newSettings","d","editMode","a","textWrap","notePadding","positionX","positionY","pointHandle","cx","cy","move","circleHandles","r1","r2","padding","h","Math","addHandles","group","handles","r","select","leftRightDynamic","align","topBottomDynamic","orientationTopBottom","orientationLeftRight","bbox","width","height","orientation","offset","lineBuilder","curve","curveLinear","canvasContext","classID","lineGen","line","builder","arcBuilder","arcShape","arc","components","lineSetup","subjectType","annotation","x1","x2","y1","y2","subjectData","angle","diffY","diffX","xe","ye","opposite","length","connectorData","createPoints","cHandles","c","index","updatePoint","event","drag","anchors","diff","p","i","start","end","scale","size","angleOffset","dot","radius","radiusPadding","updateRadius","rect","updateWidth","updateHeight","rHandles","typeSettings","innerRadius","notCornerOffset","placement","transform","circlebg","circle","outerRadius","pointer","notCornerPointerXY","sign","v","dragBadge","bHandles","text","Type","dispatcher","handler","addHandlers","component","name","Array","attrs","el","addAttrs","removeAttrs","currentAttrs","attr","bboxWithoutHandles","parseFloat","context","subjectParams","subjectCircle","subjectRect","subjectThreshold","subjectBadge","connectorParams","connectorCurve","connectorElbow","connectorLine","endType","s","e","distance","endScale","connectorDot","noteData","noteParams","lineType","noteVertical","noteHorizontal","dragging","noteAlignment","position","customType","init","babelHelpers.get","babelHelpers.extends","d3NoteText","params","noteContent","titleBBox","label","wrapLength","wrapSplitter","bgPadding","bgPaddingFinal","top","bottom","left","right","title","d3Label","d3Callout","d3CalloutElbow","d3CalloutCurve","d3Badge","d3CalloutCircle","d3CalloutRect","ThresholdMap","d3XYThreshold","newWithClass","wrap","lineHeight","words","w","word","tspan","selector","yOffset","collection","ids","annotationDispatcher","dispatch","sel","translatedAnnotations","annotationG","selection","arguments","settings","rerun","value"],"mappings":"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","sourcesContent":["export default class Annotation {\n  constructor({\n    x = 0,\n    y = 0,\n    nx,\n    ny,\n    dy = 0,\n    dx = 0,\n    color = \"grey\",\n    data,\n    type,\n    subject,\n    connector,\n    note,\n    disable,\n    id,\n    className\n  }) {\n    this._dx = nx !== undefined ? nx - x : dx\n    this._dy = ny !== undefined ? ny - y : dy\n    this._x = x\n    this._y = y\n    this._color = color\n    this.id = id\n    this._className = className || \"\"\n\n    this._type = type || \"\"\n    this.data = data\n\n    this.note = note || {}\n    this.connector = connector || {}\n    this.subject = subject || {}\n\n    this.disable = disable || []\n  }\n\n  updatePosition() {\n    if (this.type.setPosition) {\n      this.type.setPosition()\n      if (\n        this.type.subject &&\n        this.type.subject.selectAll(\":not(.handle)\").nodes().length !== 0\n      ) {\n        this.type.redrawSubject()\n      }\n    }\n  }\n\n  clearComponents() {\n    this.type.clearComponents && this.type.clearComponents()\n  }\n\n  get className() {\n    return this._className\n  }\n\n  set className(className) {\n    this._className = className\n    if (this.type.setClassName) this.type.setClassName()\n  }\n\n  updateOffset() {\n    if (this.type.setOffset) {\n      this.type.setOffset()\n\n      if (this.type.connector.selectAll(\":not(.handle)\").nodes().length !== 0) {\n        this.type.redrawConnector()\n      }\n\n      this.type.redrawNote()\n    }\n  }\n\n  get type() {\n    return this._type\n  }\n\n  set type(type) {\n    this._type = type\n    this.clearComponents()\n  }\n\n  get x() {\n    return this._x\n  }\n  set x(x) {\n    this._x = x\n    this.updatePosition()\n  }\n\n  get y() {\n    return this._y\n  }\n  set y(y) {\n    this._y = y\n    this.updatePosition()\n  }\n\n  get color() {\n    return this._color\n  }\n  set color(color) {\n    this._color = color\n    this.updatePosition()\n  }\n\n  get dx() {\n    return this._dx\n  }\n  set dx(dx) {\n    this._dx = dx\n    this.updateOffset()\n  }\n\n  get dy() {\n    return this._dy\n  }\n  set dy(dy) {\n    this._dy = dy\n    this.updateOffset()\n  }\n\n  set nx(nx) {\n    this._dx = nx - this._x\n    this.updateOffset()\n  }\n\n  set ny(ny) {\n    this._dy = ny - this._y\n    this.updateOffset()\n  }\n\n  get offset() {\n    return { x: this._dx, y: this._dy }\n  }\n\n  set offset({ x, y }) {\n    this._dx = x\n    this._dy = y\n    this.updateOffset()\n  }\n\n  get position() {\n    return { x: this._x, y: this._y }\n  }\n\n  set position({ x, y }) {\n    this._x = x\n    this._y = y\n    this.updatePosition()\n  }\n\n  get translation() {\n    return {\n      x: this._x + this._dx,\n      y: this._y + this._dy\n    }\n  }\n\n  get json() {\n    const json = {\n      x: this._x,\n      y: this._y,\n      dx: this._dx,\n      dy: this._dy\n    }\n\n    if (this.data && Object.keys(this.data).length > 0) json.data = this.data\n    if (this.type) json.type = this.type\n    if (this._className) json.className = this._className\n\n    if (Object.keys(this.connector).length > 0) json.connector = this.connector\n    if (Object.keys(this.subject).length > 0) json.subject = this.subject\n    if (Object.keys(this.note).length > 0) json.note = this.note\n\n    return json\n  }\n}\n","export default class AnnotationCollection {\n\n  constructor ({ annotations, accessors, accessorsInverse }) {\n    this.accessors = accessors\n    this.accessorsInverse = accessorsInverse\n    this.annotations = annotations\n  }\n\n  clearTypes (newSettings) {\n    this.annotations.forEach(d => {\n      d.type = undefined\n      d.subject = newSettings && newSettings.subject || d.subject\n      d.connector = newSettings && newSettings.connector || d.connector\n      d.note = newSettings && newSettings.note || d.note\n    })\n  }\n\n  setPositionWithAccessors () {\n    this.annotations.forEach(d => {\n      d.type.setPositionWithAccessors(this.accessors)\n    })\n  }\n\n  editMode (editMode) { this.annotations.forEach(a => {\n    if (a.type) {\n      a.type.editMode = editMode\n      a.type.updateEditMode()\n    }\n  })\n  }\n\n  updateDisable (disable) {\n    this.annotations.forEach(a => {\n      a.disable = disable\n      if (a.type) {\n        disable.forEach(d => {\n          if (a.type[d]) {\n            a.type[d].remove && a.type[d].remove()\n            a.type[d] = undefined\n          }\n        })\n      }\n    })\n  }\n\n  updateTextWrap (textWrap) {\n    this.annotations.forEach(a => {\n      if (a.type && a.type.updateTextWrap) {\n        a.type.updateTextWrap(textWrap)\n      }\n    })\n  }\n\n  updateText () {\n    this.annotations.forEach(a => {\n      if (a.type && a.type.drawText) {\n        a.type.drawText()\n      }\n    })\n  }\n\n  updateNotePadding (notePadding) {\n    this.annotations.forEach(a => {\n      if (a.type) {\n        a.type.notePadding = notePadding\n      }\n    })\n  }\n\n  get json () { \n    return this.annotations.map(a => {      \n      const json = a.json\n      if (this.accessorsInverse && a.data) {\n        json.data = {}\n        Object.keys(this.accessorsInverse).forEach(k => {\n          json.data[k] = this.accessorsInverse[k]({ x: a.x, y: a.y})\n\n          //TODO make this feasible to map back to data for other types of subjects\n        })\n      }\n      return json\n    })\n  }\n\n  get noteNodes () {\n    return this.annotations.map(a => ({ ...a.type.getNoteBBoxOffset(), positionX: a.x, positionY: a.y }))\n  }\n\n  //TODO: come back and rethink if a.x and a.y are applicable in all situations\n  // get connectorNodes() {\n  //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))\n  // }\n\n  // get subjectNodes() {\n  //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))\n  // }\n\n  // get annotationNodes() {\n  //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))\n  // }\n}\n","import { select } from \"d3-selection\"\nimport { drag } from \"d3-drag\"\n\nexport const pointHandle = ({ cx = 0, cy = 0 }) => {\n  return { move: { x: cx, y: cy } }\n}\n\nexport const circleHandles = ({ cx = 0, cy = 0, r1, r2, padding }) => {\n  const h = { move: { x: cx, y: cy } }\n\n  if (r1 !== undefined) {\n    h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) }\n  }\n\n  if (r2 !== undefined) {\n    h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) }\n  }\n\n  if (padding !== undefined) {\n    h.padding = { x: cx + r1 + padding, y: cy }\n  }\n\n  return h\n}\n\nexport const rectHandles = ({\n  x1 = 0,\n  y1 = 0,\n  x2 = x1,\n  y2 = y1,\n  width,\n  height\n}) => {\n  const w = width || Math.abs(x2 - x1)\n  const h = height || Math.abs(y2 - y1)\n\n  return {\n    move: {\n      x: Math.min(x1, x2) + w / 2,\n      y: Math.min(y1, y2) - 10\n    },\n    width: {\n      x: Math.max(x1, x2),\n      y: Math.min(y1, y2) + h / 2\n    },\n    height: {\n      x: Math.min(x1, x2) + w / 2,\n      y: Math.max(y1, y2)\n    }\n  }\n}\n\nexport const lineHandles = ({ x1, y1, x2, y2, x, y }) => {\n  const minY = Math.min(y1, y2)\n  const minX = Math.min(x1, x2)\n\n  const height = Math.abs(y2 - y1)\n  const width = Math.abs(x2 - x1)\n\n  return {\n    move: {\n      x: x || minX + width / 2,\n      y: y || minY + height / 2\n    }\n  }\n}\n\n//arc handles\nexport const addHandles = ({ group, handles, r = 10 }) => {\n  //give it a group and x,y to draw handles\n  //then give it instructions on what the handles change\n  const h = group.selectAll(\"circle.handle\").data(handles)\n\n  h\n    .enter()\n    .append(\"circle\")\n    .attr(\"class\", \"handle\")\n    .attr(\"fill\", \"grey\")\n    .attr(\"fill-opacity\", 0.1)\n    .attr(\"cursor\", \"move\")\n    .attr(\"stroke-dasharray\", 5)\n    .attr(\"stroke\", \"grey\")\n    .call(\n      drag()\n        .container(select(\"g.annotations\").node())\n        .on(\"start\", d => d.start && d.start(d))\n        .on(\"drag\", d => d.drag && d.drag(d))\n        .on(\"end\", d => d.end && d.end(d))\n    )\n\n  group\n    .selectAll(\"circle.handle\")\n    .attr(\"cx\", d => d.x)\n    .attr(\"cy\", d => d.y)\n    .attr(\"r\", d => d.r || r)\n    .attr(\"class\", d => `handle ${d.className || \"\"}`)\n\n  h.exit().remove()\n}\n","\nexport const leftRightDynamic = (align, y) => {\n  if (align === \"dynamic\" || align === \"left\" || align === \"right\") {\n    if (y < 0) { align = \"top\" }\n    else { align = \"bottom\" } \n  }\n  return align\n}\n\nexport const topBottomDynamic = (align, x) => {\n  if (align === \"dynamic\" || align === \"top\" || align === \"bottom\") {\n    if (x < 0) { align = \"right\" }\n    else { align = \"left\" }      \n  }\n  return align\n}\n\nconst orientationTopBottom = [\"topBottom\", \"top\", \"bottom\"]\nconst orientationLeftRight = [\"leftRight\", \"left\", \"right\"]\n\nexport default ({ padding=0, bbox={x:0, y:0, width:0, height:0}, align, orientation, offset={x:0, y:0} }) => {\n  let x = -bbox.x \n  let y = 0//-bbox.y\n  if ( orientationTopBottom.indexOf(orientation) !== -1 ) {\n    align = topBottomDynamic(align, offset.x)\n    if (offset.y < 0 && orientation === \"topBottom\" || orientation === \"top\") { \n      y -= bbox.height + padding\n    } else {\n      y += padding\n    }\n\n    if ( align === \"middle\" ) {\n      x -= bbox.width/2\n    } else if (align === \"right\" ) {\n      x -= bbox.width\n    } \n\n  } else if ( orientationLeftRight.indexOf(orientation) !== -1 ) {\n    align = leftRightDynamic(align, offset.y)\n    if (offset.x < 0 && orientation === \"leftRight\" || orientation === \"left\") { \n      x -= bbox.width + padding\n    } else {\n      x += padding\n    }\n\n    if ( align === \"middle\" ) {\n      y -= bbox.height/2\n    } else if (align === \"top\" ) {\n      y -= bbox.height\n    }\n  } \n\n  return { x, y }\n}","import { line, arc, curveLinear } from \"d3-shape\"\n\nexport const lineBuilder = ({ data, curve=curveLinear, canvasContext, className, classID }) => { \n  const lineGen = line()\n    .curve(curve)\n\n  const builder = {\n    type: 'path',\n    className,\n    classID,\n    data\n  }\n\n  if (canvasContext) {\n    lineGen.context(canvasContext)\n    builder.pathMethods = lineGen\n\n  } else {\n    builder.attrs = {\n      d: lineGen(data)\n    }\n  }\n\n  return builder\n}\n\nexport const arcBuilder = ({ data, canvasContext, className, classID }) => {\n\n  const builder = {\n    type: 'path',\n    className,\n    classID,\n    data\n  }\n\n  const arcShape = arc()\n    .innerRadius(data.innerRadius || 0)\n    .outerRadius(data.outerRadius || data.radius || 2)\n    .startAngle(data.startAngle || 0)\n    .endAngle(data.endAngle || 2*Math.PI)\n\n  if (canvasContext) {\n    arcShape.context(canvasContext)\n    builder.pathMethods = lineGen\n\n  } else {\n    \n    builder.attrs = {\n      d: arcShape()\n    }\n  }\n\n  return builder\n}","import { lineBuilder } from '../Builder'\nimport { leftRightDynamic } from './alignment'\n\nexport default ({ align, x=0, y=0, bbox, offset }) => {\n  align = leftRightDynamic(align, offset.y)\n\n  if (align === \"top\") { y -= bbox.height } \n  else if (align === \"middle\") { y -= bbox.height/2 }\n\n  const data = [[x, y], [x, y + bbox.height]]\n  return { components: [lineBuilder({ data, className : \"note-line\" })] }\n}","import { lineBuilder } from '../Builder'\nimport { topBottomDynamic } from './alignment'\n\nexport default ({ align, x=0, y=0, offset, bbox }) => {\n  align = topBottomDynamic(align, offset.x)\n\n  if (align === \"right\") { x -= bbox.width }\n  else if (align === \"middle\") { x -= bbox.width/2 }\n\n  const data = [[x, y], [x + bbox.width, y]]\n  return { components: [lineBuilder({ data, className : \"note-line\" })] }\n}","import { lineBuilder } from '../Builder'\n\nexport const lineSetup = ({ type, subjectType }) => {\n  let annotation = type.annotation\n  let offset = annotation.position\n  \n  let x1 = annotation.x - offset.x,\n    x2 = x1 + annotation.dx,\n    y1 = annotation.y - offset.y,\n    y2 = y1 + annotation.dy\n\n\n  const subjectData = annotation.subject\n\n  if (subjectType === \"circle\" && (subjectData.outerRadius || subjectData.radius)) {\n    const h =  Math.sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2))\n    const angle = Math.asin(-y2/h)\n    const r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0)\n\n    x1 = Math.abs(Math.cos(angle)*r)*(x2 < 0 ? -1 : 1)\n    y1 = Math.abs(Math.sin(angle)*r)*(y2 < 0 ? -1 : 1)\n\n  }\n\n  if (subjectType === \"rect\") {\n    const { width, height } = subjectData\n    \n    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {\n      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width/2\n      else x1 = width\n    } \n    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {\n      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height/2\n      else y1 = height\n    }\n    if (x1 === width/2 && y1 === height/2) { x1 = x2; y1 = y2;}\n  }\n\n\n  return [[x1, y1], [x2, y2]]\n}\n\nexport default (connectorData) => {\n  const data = lineSetup(connectorData)\n  return { components: [lineBuilder({ data, className : \"connector\" })]} \n}","import { lineBuilder } from '../Builder'\n\nexport default ({ type, subjectType }) => {\n\n  const annotation = type.annotation\n  const offset = annotation.position\n\n  let x1 = annotation.x - offset.x,\n    x2 = x1 + annotation.dx,\n    y1 = annotation.y - offset.y,\n    y2 = y1 + annotation.dy\n\n  const subjectData = annotation.subject\n\n  if (subjectType === \"rect\") {\n    const { width, height } = subjectData\n    \n    if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {\n      if (Math.abs(width) > Math.abs(annotation.dx)) x1 = width/2\n      else x1 = width\n    } \n    if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {\n      if (Math.abs(height) > Math.abs(annotation.dy)) y1 = height/2\n      else y1 = height\n    }\n    if (x1 === width/2 && y1 === height/2) { x1 = x2; y1 = y2;}\n  }\n\n  let data = [[x1, y1], [x2, y2]]\n\n  let diffY = y2 - y1\n  let diffX = x2 - x1\n  let xe = x2 \n  let ye = y2\n  let opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1\n\n  if (Math.abs(diffX) < Math.abs(diffY)) {\n    xe = x2\n    ye = y1 + diffX*opposite\n  } else {\n    ye = y2\n    xe = x1 + diffY*opposite\n  }\n  \n  if (subjectType === \"circle\" && (subjectData.outerRadius || subjectData.radius)) {\n    const r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0)\n    const length = r/Math.sqrt(2)\n\n    if (Math.abs(diffX) > length && Math.abs(diffY) > length) {\n      x1 = length*(x2 < 0 ? -1 : 1)\n      y1 = length*(y2 < 0 ? -1 : 1)\n      data = [[x1, y1], [xe , ye ], [x2, y2]]\n\n    } else if (Math.abs(diffX) > Math.abs(diffY)) {\n      const angle = Math.asin(-y2/r)\n      x1 = Math.abs(Math.cos(angle)*r)*(x2 < 0 ? -1 : 1)\n      data = [[ x1, y2], [x2, y2]]\n    } else {\n      const angle = Math.acos(x2/r)\n      y1 = Math.abs(Math.sin(angle)*r)*(y2 < 0 ? -1 : 1)\n      data = [[ x2, y1], [x2, y2]]\n    }\n  } else {\n    data = [[x1, y1], [xe , ye], [x2, y2]]\n  }\n\n  return { components: [lineBuilder({ data, className: \"connector\"})]}\n}\n","import { lineBuilder } from '../Builder'\nimport { event } from 'd3-selection'\nimport { lineSetup } from './type-line'\nimport { curveCatmullRom } from 'd3-shape'\nimport { pointHandle } from '../Handles'\n\nexport default ({ type, connectorData, subjectType }) => {\n\n  if (!connectorData) { connectorData = {} }\n  if (!connectorData.points || typeof connectorData.points === \"number\") { \n    connectorData.points = createPoints(type.annotation.offset, connectorData.points) \n  }\n  if (!connectorData.curve) { connectorData.curve = curveCatmullRom }\n\n  let handles = []\n\n  if (type.editMode) {\n    const cHandles = connectorData.points\n      .map((c,i) => ({...pointHandle({cx: c[0], cy: c[1]}), index: i}))\n\n    const updatePoint = (index) => {      \n      connectorData.points[index][0] += event.dx\n      connectorData.points[index][1] += event.dy\n      type.redrawConnector()\n    }\n  \n    handles = type.mapHandles(cHandles\n      .map(h => ({ ...h.move, drag: updatePoint.bind(type, h.index)})))\n\n  }\n\n  let data = lineSetup({ type, subjectType })\n  data = [data[0], ...connectorData.points, data[1]]\n  const components = [lineBuilder({ data, curve: connectorData.curve, className: \"connector\" })]\n\n  return { components , handles }\n}\n\nconst createPoints = function ( offset, anchors=2) {\n  const diff = { x: offset.x/(anchors + 1), y: offset.y/(anchors + 1) }\n  const p = []\n\n  let i = 1 \n  for (; i <= anchors; i++) {\n    p.push([diff.x*i + i%2*20, diff.y*i - i%2*20])\n  }\n  return p\n}","import { lineBuilder } from \"../Builder\"\n\nexport default ({ annotation, start, end, scale = 1 }) => {\n  const offset = annotation.position\n  if (!start) {\n    start = [annotation.dx, annotation.dy]\n  } else {\n    start = [-end[0] + start[0], -end[1] + start[1]]\n  }\n  if (!end) {\n    end = [annotation.x - offset.x, annotation.y - offset.y]\n  }\n\n  let x1 = end[0],\n    y1 = end[1]\n\n  let dx = start[0]\n  let dy = start[1]\n\n  let size = 10 * scale\n  let angleOffset = 16 / 180 * Math.PI\n  let angle = Math.atan(dy / dx)\n\n  if (dx < 0) {\n    angle += Math.PI\n  }\n\n  const data = [\n    [x1, y1],\n    [\n      Math.cos(angle + angleOffset) * size + x1,\n      Math.sin(angle + angleOffset) * size + y1\n    ],\n    [\n      Math.cos(angle - angleOffset) * size + x1,\n      Math.sin(angle - angleOffset) * size + y1\n    ],\n    [x1, y1]\n  ]\n\n  //TODO add in reverse\n  // if (canvasContext.arrowReverse){\n  //   data = [[x1, y1],\n  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],\n  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],\n  //   [x1, y1]\n  //   ]\n  // } else {\n  //   data = [[x1, y1],\n  //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],\n  //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],\n  //   [x1, y1]\n  //   ]\n  // }\n\n  return {\n    components: [\n      lineBuilder({\n        data,\n        className: \"connector-end connector-arrow\",\n        classID: \"connector-end\"\n      })\n    ]\n  }\n}\n","import { arcBuilder } from \"../Builder\"\n\nexport default ({ line, scale = 1 }) => {\n  let dot = arcBuilder({\n    className: \"connector-end connector-dot\",\n    classID: \"connector-end\",\n    data: { radius: 3 * Math.sqrt(scale) }\n  })\n  dot.attrs.transform = `translate(${line.data[0][0]}, ${line.data[0][1]})`\n\n  return { components: [dot] }\n}\n","import { circleHandles } from \"../Handles\"\nimport { arcBuilder } from \"../Builder\"\nimport { event } from \"d3-selection\"\n\nexport default ({ subjectData, type }) => {\n  if (!subjectData.radius && !subjectData.outerRadius) {\n    subjectData.radius = 20\n  }\n\n  let handles = []\n  const c = arcBuilder({ data: subjectData, className: \"subject\" })\n  if (type.editMode) {\n    const h = circleHandles({\n      r1: c.data.outerRadius || c.data.radius,\n      r2: c.data.innerRadius,\n      padding: subjectData.radiusPadding\n    })\n\n    const updateRadius = attr => {\n      const r = subjectData[attr] + event.dx * Math.sqrt(2)\n      subjectData[attr] = r\n      type.redrawSubject()\n      type.redrawConnector()\n    }\n\n    const cHandles = [\n      {\n        ...h.r1,\n        drag: updateRadius.bind(\n          type,\n          subjectData.outerRadius !== undefined ? \"outerRadius\" : \"radius\"\n        )\n      }\n    ]\n\n    if (subjectData.innerRadius) {\n      cHandles.push({ ...h.r2, drag: updateRadius.bind(type, \"innerRadius\") })\n    }\n    handles = type.mapHandles(cHandles)\n  }\n\n  c.attrs[\"fill-opacity\"] = 0\n\n  return { components: [c], handles }\n}\n","import { lineBuilder } from \"../Builder\"\nimport { event } from \"d3-selection\"\n\nexport default ({ subjectData, type }) => {\n  if (!subjectData.width) {\n    subjectData.width = 100\n  }\n  if (!subjectData.height) {\n    subjectData.height = 100\n  }\n\n  let handles = []\n  let { width, height } = subjectData\n\n  const data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]]\n  let rect = lineBuilder({ data, className: \"subject\" })\n\n  if (type.editMode) {\n    const updateWidth = () => {\n      subjectData.width = event.x\n      type.redrawSubject()\n      type.redrawConnector()\n    }\n\n    const updateHeight = () => {\n      subjectData.height = event.y\n      type.redrawSubject()\n      type.redrawConnector()\n    }\n\n    const rHandles = [\n      { x: width, y: height / 2, drag: updateWidth.bind(type) },\n      { x: width / 2, y: height, drag: updateHeight.bind(type) }\n    ]\n\n    handles = type.mapHandles(rHandles)\n  }\n  rect.attrs[\"fill-opacity\"] = 0.1\n  return { components: [rect], handles }\n}\n","import { lineBuilder } from '../Builder'\n\n\nexport default ({ subjectData, type }) => {\n  const offset = type.annotation.position\n\n  let x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x,\n    x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x,\n    y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y,\n    y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y\n\n  const data = [[x1, y1], [x2, y2]]\n  return { components: [lineBuilder({ data, className : 'subject'})]}\n}","import { lineBuilder, arcBuilder } from \"../Builder\"\nimport { event } from \"d3-selection\"\n\nexport default ({ subjectData = {}, type = {} }, annotation = {}) => {\n  const typeSettings = type.typeSettings && type.typeSettings.subject\n\n  if (!subjectData.radius) {\n    if (typeSettings && typeSettings.radius) {\n      subjectData.radius = typeSettings.radius\n    } else {\n      subjectData.radius = 14\n    }\n  }\n  if (!subjectData.x) {\n    if (typeSettings && typeSettings.x) {\n      subjectData.x = typeSettings.x\n    }\n  }\n  if (!subjectData.y) {\n    if (typeSettings && typeSettings.y) {\n      subjectData.y = typeSettings.y\n    }\n  }\n\n  let handles = []\n  const components = []\n  const radius = subjectData.radius\n  const innerRadius = radius * 0.7\n  let x = 0\n  let y = 0\n\n  const notCornerOffset = Math.sqrt(2) * radius\n  const placement = {\n    xleftcorner: -radius,\n    xrightcorner: radius,\n    ytopcorner: -radius,\n    ybottomcorner: radius,\n    xleft: -notCornerOffset,\n    xright: notCornerOffset,\n    ytop: -notCornerOffset,\n    ybottom: notCornerOffset\n  }\n\n  if (subjectData.x && !subjectData.y) {\n    x = placement[`x${subjectData.x}`]\n  } else if (subjectData.y && !subjectData.x) {\n    y = placement[`y${subjectData.y}`]\n  } else if (subjectData.x && subjectData.y) {\n    x = placement[`x${subjectData.x}corner`]\n    y = placement[`y${subjectData.y}corner`]\n  }\n\n  const transform = `translate(${x}, ${y})`\n  const circlebg = arcBuilder({ className: \"subject\", data: { radius } })\n  circlebg.attrs.transform = transform\n  circlebg.attrs.fill = annotation.color\n  circlebg.attrs[\"stroke-linecap\"] = \"round\"\n  circlebg.attrs[\"stroke-width\"] = \"3px\"\n\n  const circle = arcBuilder({\n    className: \"subject-ring\",\n    data: { outerRadius: radius, innerRadius }\n  })\n\n  circle.attrs.transform = transform\n  // circle.attrs.fill = annotation.color\n  circle.attrs[\"stroke-width\"] = \"3px\"\n  circle.attrs.fill = \"white\"\n\n  let pointer\n  if (x && y || !x && !y) {\n    pointer = lineBuilder({\n      className: \"subject-pointer\",\n      data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]\n    })\n  } else if (x || y) {\n    const notCornerPointerXY = (v, sign = 1) =>\n      v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2)\n\n    pointer = lineBuilder({\n      className: \"subject-pointer\",\n      data: [\n        [0, 0],\n        [notCornerPointerXY(x), notCornerPointerXY(y)],\n        [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)],\n        [0, 0]\n      ]\n    })\n  }\n\n  if (pointer) {\n    pointer.attrs.fill = annotation.color\n    pointer.attrs[\"stroke-linecap\"] = \"round\"\n    pointer.attrs[\"stroke-width\"] = \"3px\"\n    components.push(pointer)\n  }\n\n  if (type.editMode) {\n    const dragBadge = () => {\n      subjectData.x =\n        event.x < -radius * 2\n          ? \"left\"\n          : event.x > radius * 2 ? \"right\" : undefined\n      subjectData.y =\n        event.y < -radius * 2\n          ? \"top\"\n          : event.y > radius * 2 ? \"bottom\" : undefined\n\n      type.redrawSubject()\n    }\n\n    const bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) }\n    if (!bHandles.x && !bHandles.y) {\n      bHandles.y = -radius\n    }\n\n    handles = type.mapHandles([bHandles])\n  }\n\n  let text\n  if (subjectData.text) {\n    text = {\n      type: \"text\",\n      className: \"badge-text\",\n      attrs: {\n        fill: \"white\",\n        stroke: \"none\",\n        \"font-size\": \".7em\",\n        text: subjectData.text,\n        \"text-anchor\": \"middle\",\n        dy: \".25em\",\n        x,\n        y\n      }\n    }\n  }\n\n  components.push(circlebg)\n  components.push(circle)\n  components.push(text)\n\n  return { components, handles }\n}\n","import { select, event } from \"d3-selection\"\nimport { drag } from \"d3-drag\"\nimport { addHandles } from \"./Handles\"\n\n//Note options\nimport noteAlignment from \"./Note/alignment\"\nimport noteVertical from \"./Note/lineType-vertical\"\nimport noteHorizontal from \"./Note/lineType-horizontal\"\n\n//Connector options\nimport connectorLine from \"./Connector/type-line\"\nimport connectorElbow from \"./Connector/type-elbow\"\nimport connectorCurve from \"./Connector/type-curve\"\nimport connectorArrow from \"./Connector/end-arrow\"\nimport connectorDot from \"./Connector/end-dot\"\n\n//Subject options\nimport subjectCircle from \"./Subject/circle\"\nimport subjectRect from \"./Subject/rect\"\nimport subjectThreshold from \"./Subject/threshold\"\nimport subjectBadge from \"./Subject/badge\"\n\nexport class Type {\n  constructor({ a, annotation, editMode, dispatcher, notePadding, accessors }) {\n    this.a = a\n\n    this.note =\n      annotation.disable.indexOf(\"note\") === -1 && a.select(\"g.annotation-note\")\n    this.noteContent = this.note && a.select(\"g.annotation-note-content\")\n    this.connector =\n      annotation.disable.indexOf(\"connector\") === -1 &&\n      a.select(\"g.annotation-connector\")\n    this.subject =\n      annotation.disable.indexOf(\"subject\") === -1 &&\n      a.select(\"g.annotation-subject\")\n    this.dispatcher = dispatcher\n\n    if (dispatcher) {\n      const handler = addHandlers.bind(null, dispatcher, annotation)\n      handler({ component: this.note, name: \"note\" })\n      handler({ component: this.connector, name: \"connector\" })\n      handler({ component: this.subject, name: \"subject\" })\n    }\n\n    this.annotation = annotation\n    this.editMode = annotation.editMode || editMode\n    this.notePadding = notePadding !== undefined ? notePadding : 3\n    this.offsetCornerX = 0\n    this.offsetCornerY = 0\n\n    if (accessors && annotation.data) {\n      this.init(accessors)\n    }\n  }\n\n  init(accessors) {\n    if (!this.annotation.x) {\n      this.mapX(accessors)\n    }\n    if (!this.annotation.y) {\n      this.mapY(accessors)\n    }\n  }\n\n  mapY(accessors) {\n    if (accessors.y) {\n      this.annotation.y = accessors.y(this.annotation.data)\n    }\n  }\n\n  mapX(accessors) {\n    if (accessors.x) {\n      this.annotation.x = accessors.x(this.annotation.data)\n    }\n  }\n\n  updateEditMode() {\n    this.a.selectAll(\"circle.handle\").remove()\n  }\n\n  drawOnSVG(component, builders) {\n    if (!Array.isArray(builders)) {\n      builders = [builders]\n    }\n\n    builders\n      .filter(b => b)\n      .forEach(({ type, className, attrs, handles, classID }) => {\n        if (type === \"handle\") {\n          addHandles({ group: component, r: attrs && attrs.r, handles })\n        } else {\n          newWithClass(component, [this.annotation], type, className, classID)\n          const el = component.select(`${type}.${classID || className}`)\n          const addAttrs = Object.keys(attrs)\n          const removeAttrs = []\n\n          const currentAttrs = el.node().attributes\n          for (let i = currentAttrs.length - 1; i >= 0; i--) {\n            const name = currentAttrs[i].name\n            if (addAttrs.indexOf(name) === -1 && name !== \"class\")\n              removeAttrs.push(name)\n          }\n\n          addAttrs.forEach(attr => {\n            if (attr === \"text\") {\n              el.text(attrs[attr])\n            } else {\n              el.attr(attr, attrs[attr])\n            }\n          })\n\n          removeAttrs.forEach(attr => el.attr(attr, null))\n        }\n      })\n  }\n\n  //TODO: how to extend this to a drawOnCanvas mode?\n\n  getNoteBBox() {\n    return bboxWithoutHandles(this.note, \".annotation-note-content text\")\n  }\n  getNoteBBoxOffset() {\n    const bbox = bboxWithoutHandles(this.note, \".annotation-note-content\")\n    const transform = this.noteContent.attr(\"transform\").split(/\\(|\\,|\\)/g)\n    bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx\n    bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy\n    bbox.offsetX = this.annotation.dx\n    bbox.offsetY = this.annotation.dy\n    return bbox\n  }\n\n  drawSubject(context = {}) {\n    const subjectData = this.annotation.subject\n    const type = context.type\n    const subjectParams = { type: this, subjectData }\n\n    let subject = {}\n    if (type === \"circle\") subject = subjectCircle(subjectParams)\n    else if (type === \"rect\") subject = subjectRect(subjectParams)\n    else if (type === \"threshold\") subject = subjectThreshold(subjectParams)\n    else if (type === \"badge\")\n      subject = subjectBadge(subjectParams, this.annotation)\n\n    let { components = [], handles = [] } = subject\n    components.forEach(c => {\n      if (c && c.attrs && !c.attrs.stroke) {\n        c.attrs.stroke = this.annotation.color\n      }\n    })\n\n    if (this.editMode) {\n      handles = handles.concat(\n        this.mapHandles([{ drag: this.dragSubject.bind(this) }])\n      )\n      components.push({ type: \"handle\", handles })\n    }\n\n    return components\n  }\n\n  drawConnector(context = {}) {\n    const connectorData = this.annotation.connector\n    const type = connectorData.type || context.type\n    const connectorParams = { type: this, connectorData }\n    connectorParams.subjectType =\n      this.typeSettings &&\n      this.typeSettings.subject &&\n      this.typeSettings.subject.type\n\n    let connector = {}\n    if (type === \"curve\") connector = connectorCurve(connectorParams)\n    else if (type === \"elbow\") connector = connectorElbow(connectorParams)\n    else connector = connectorLine(connectorParams)\n    let { components = [], handles = [] } = connector\n    const line = components[0]\n    //TODO: genericize this into fill t/f stroke t/f\n    if (line) {\n      line.attrs.stroke = this.annotation.color\n      line.attrs.fill = \"none\"\n    }\n    const endType = connectorData.end || context.end\n    let end = {}\n    if (endType === \"arrow\") {\n      let s = line.data[1]\n      const e = line.data[0]\n      const distance = Math.sqrt(\n        Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2)\n      )\n      if (distance < 5 && line.data[2]) {\n        s = line.data[2]\n      }\n      end = connectorArrow({\n        annotation: this.annotation,\n        start: s,\n        end: e,\n        scale: connectorData.endScale\n      })\n    } else if (endType === \"dot\") {\n      end = connectorDot({ line, scale: connectorData.endScale })\n    } else if (!endType || endType === \"none\") {\n      this.connector && this.connector.select(\".connector-end\").remove()\n    }\n\n    if (end.components) {\n      end.components.forEach(c => {\n        c.attrs.fill = this.annotation.color\n        c.attrs.stroke = this.annotation.color\n      })\n      components = components.concat(end.components)\n    }\n\n    if (this.editMode) {\n      if (handles.length !== 0) components.push({ type: \"handle\", handles })\n    }\n    return components\n  }\n\n  drawNote(context = {}) {\n    const noteData = this.annotation.note\n    const align = noteData.align || context.align || \"dynamic\"\n    const noteParams = {\n      bbox: context.bbox,\n      align,\n      offset: this.annotation.offset\n    }\n    const lineType = noteData.lineType || context.lineType\n    let note = {}\n    if (lineType === \"vertical\") note = noteVertical(noteParams)\n    else if (lineType === \"horizontal\") note = noteHorizontal(noteParams)\n\n    let { components = [], handles = [] } = note\n    components.forEach(c => {\n      c.attrs.stroke = this.annotation.color\n    })\n\n    if (this.editMode) {\n      handles = this.mapHandles([\n        { x: 0, y: 0, drag: this.dragNote.bind(this) }\n      ])\n      components.push({ type: \"handle\", handles })\n\n      const dragging = this.dragNote.bind(this),\n        start = this.dragstarted.bind(this),\n        end = this.dragended.bind(this)\n      this.note.call(\n        drag()\n          .container(select(\"g.annotations\").node())\n          .on(\"start\", d => start(d))\n          .on(\"drag\", d => dragging(d))\n          .on(\"end\", d => end(d))\n      )\n    } else {\n      this.note.on(\"mousedown.drag\", null)\n    }\n    return components\n  }\n\n  drawNoteContent(context) {\n    const noteData = this.annotation.note\n    const padding =\n      noteData.padding !== undefined ? noteData.padding : this.notePadding\n    let orientation = noteData.orientation || context.orientation || \"topBottom\"\n    const lineType = noteData.lineType || context.lineType\n    const align = noteData.align || context.align || \"dynamic\"\n\n    if (lineType === \"vertical\") orientation = \"leftRight\"\n    else if (lineType === \"horizontal\") orientation = \"topBottom\"\n\n    const noteParams = {\n      padding,\n      bbox: context.bbox,\n      offset: this.annotation.offset,\n      orientation,\n      align\n    }\n    const { x, y } = noteAlignment(noteParams)\n    this.offsetCornerX = x + this.annotation.dx\n    this.offsetCornerY = y + this.annotation.dy\n    this.note && this.noteContent.attr(\"transform\", `translate(${x}, ${y})`)\n\n    return []\n  }\n\n  drawOnScreen(component, drawFunction) {\n    return this.drawOnSVG(component, drawFunction)\n  }\n\n  redrawSubject() {\n    this.subject && this.drawOnScreen(this.subject, this.drawSubject())\n  }\n\n  redrawConnector() {\n    this.connector && this.drawOnScreen(this.connector, this.drawConnector())\n  }\n\n  redrawNote(bbox = this.getNoteBBox()) {\n    this.noteContent &&\n      this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox }))\n    this.note && this.drawOnScreen(this.note, this.drawNote({ bbox }))\n  }\n\n  setPosition() {\n    const position = this.annotation.position\n    this.a.attr(\"transform\", `translate(${position.x}, ${position.y})`)\n  }\n\n  clearComponents() {\n    this.subject && this.subject.select(\"*\").remove()\n    this.connector && this.connector.select(\"*\").remove()\n    // this.note && this.note.select(\"*\").remove()\n  }\n\n  setOffset() {\n    if (this.note) {\n      const offset = this.annotation.offset\n      this.note.attr(\"transform\", `translate(${offset.x}, ${offset.y})`)\n    }\n  }\n\n  setPositionWithAccessors(accessors) {\n    if (accessors && this.annotation.data) {\n      this.mapX(accessors)\n      this.mapY(accessors)\n    }\n    this.setPosition()\n  }\n\n  setClassName() {\n    this.a.attr(\n      \"class\",\n      `annotation ${this.className && this.className()} ${\n        this.editMode ? \"editable\" : \"\"\n      } ${this.annotation.className || \"\"}`\n    )\n  }\n\n  draw() {\n    this.setClassName()\n    this.setPosition()\n    this.setOffset()\n    this.redrawSubject()\n    this.redrawConnector()\n    this.redrawNote()\n  }\n\n  dragstarted() {\n    event.sourceEvent.stopPropagation()\n    this.dispatcher &&\n      this.dispatcher.call(\"dragstart\", this.a, this.annotation)\n    this.a.classed(\"dragging\", true)\n    this.a.selectAll(\"circle.handle\").style(\"pointer-events\", \"none\")\n  }\n  dragended() {\n    this.dispatcher && this.dispatcher.call(\"dragend\", this.a, this.annotation)\n    this.a.classed(\"dragging\", false)\n    this.a.selectAll(\"circle.handle\").style(\"pointer-events\", \"all\")\n  }\n\n  dragSubject() {\n    const position = this.annotation.position\n    position.x += event.dx\n    position.y += event.dy\n    this.annotation.position = position\n  }\n\n  dragNote() {\n    const offset = this.annotation.offset\n    offset.x += event.dx\n    offset.y += event.dy\n    this.annotation.offset = offset\n  }\n\n  mapHandles(handles) {\n    return handles.map(h => ({\n      ...h,\n      start: this.dragstarted.bind(this),\n      end: this.dragended.bind(this)\n    }))\n  }\n}\n\nexport const customType = (initialType, typeSettings, init) => {\n  return class customType extends initialType {\n    constructor(settings) {\n      super(settings)\n      this.typeSettings = typeSettings\n\n      if (typeSettings.disable) {\n        typeSettings.disable.forEach(d => {\n          this[d] && this[d].remove()\n\n          this[d] = undefined\n          if (d === \"note\") {\n            this.noteContent = undefined\n          }\n        })\n      }\n    }\n\n    static init(annotation, accessors) {\n      super.init(annotation, accessors)\n      if (init) {\n        annotation = init(annotation, accessors)\n      }\n      return annotation\n    }\n\n    className() {\n      return `${typeSettings.className ||\n        super.className && super.className() ||\n        \"\"}`\n    }\n\n    drawSubject(context) {\n      this.typeSettings.subject = Object.assign(\n        {},\n        typeSettings.subject,\n        this.typeSettings.subject\n      )\n      return super.drawSubject({ ...context, ...this.typeSettings.subject })\n    }\n\n    drawConnector(context) {\n      this.typeSettings.connector = Object.assign(\n        {},\n        typeSettings.connector,\n        this.typeSettings.connector\n      )\n      return super.drawConnector({\n        ...context,\n        ...typeSettings.connector,\n        ...this.typeSettings.connector\n      })\n    }\n\n    drawNote(context) {\n      this.typeSettings.note = Object.assign(\n        {},\n        typeSettings.note,\n        this.typeSettings.note\n      )\n      return super.drawNote({\n        ...context,\n        ...typeSettings.note,\n        ...this.typeSettings.note\n      })\n    }\n\n    drawNoteContent(context) {\n      return super.drawNoteContent({\n        ...context,\n        ...typeSettings.note,\n        ...this.typeSettings.note\n      })\n    }\n  }\n}\n\nexport class d3NoteText extends Type {\n  constructor(params) {\n    super(params)\n    this.textWrap = params.textWrap || 120\n    this.drawText()\n  }\n\n  updateTextWrap(textWrap) {\n    this.textWrap = textWrap\n    this.drawText()\n  }\n\n  //TODO: add update text functionality\n\n  drawText() {\n    if (this.note) {\n      newWithClass(this.note, [this.annotation], \"g\", \"annotation-note-content\")\n\n      const noteContent = this.note.select(\"g.annotation-note-content\")\n      newWithClass(noteContent, [this.annotation], \"rect\", \"annotation-note-bg\")\n      newWithClass(\n        noteContent,\n        [this.annotation],\n        \"text\",\n        \"annotation-note-label\"\n      )\n      newWithClass(\n        noteContent,\n        [this.annotation],\n        \"text\",\n        \"annotation-note-title\"\n      )\n\n      let titleBBox = { height: 0 }\n      const label = this.a.select(\"text.annotation-note-label\")\n      const wrapLength =\n        this.annotation.note && this.annotation.note.wrap ||\n        this.typeSettings &&\n          this.typeSettings.note &&\n          this.typeSettings.note.wrap ||\n        this.textWrap\n\n      const wrapSplitter =\n        this.annotation.note && this.annotation.note.wrapSplitter ||\n        this.typeSettings &&\n          this.typeSettings.note &&\n          this.typeSettings.note.wrapSplitter\n\n      let bgPadding =\n        this.annotation.note && this.annotation.note.bgPadding ||\n        this.typeSettings &&\n          this.typeSettings.note &&\n          this.typeSettings.note.bgPadding\n\n      let bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 }\n      if (typeof bgPadding === \"number\") {\n        bgPaddingFinal = {\n          top: bgPadding,\n          bottom: bgPadding,\n          left: bgPadding,\n          right: bgPadding\n        }\n      } else if (bgPadding && typeof bgPadding === \"object\") {\n        bgPaddingFinal = Object.assign(bgPaddingFinal, bgPadding)\n      }\n\n      if (this.annotation.note.title) {\n        const title = this.a.select(\"text.annotation-note-title\")\n        title.text(this.annotation.note.title)\n        title.attr(\"fill\", this.annotation.color)\n        title.attr(\"font-weight\", \"bold\")\n        title.call(wrap, wrapLength, wrapSplitter)\n        titleBBox = title.node().getBBox()\n      }\n\n      label.text(this.annotation.note.label).attr(\"dx\", \"0\")\n      label.call(wrap, wrapLength, wrapSplitter)\n\n      label.attr(\"y\", titleBBox.height * 1.1 || 0)\n      label.attr(\"fill\", this.annotation.color)\n\n      const bbox = this.getNoteBBox()\n\n      this.a\n        .select(\"rect.annotation-note-bg\")\n        .attr(\"width\", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right)\n        .attr(\n          \"height\",\n          bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom\n        )\n        .attr(\"x\", bbox.x - bgPaddingFinal.left)\n        .attr(\"y\", -bgPaddingFinal.top)\n        .attr(\"fill\", \"white\")\n        .attr(\"fill-opacity\", 0)\n    }\n  }\n}\n\nexport const d3Label = customType(d3NoteText, {\n  className: \"label\",\n  note: { align: \"middle\" }\n})\n\nexport const d3Callout = customType(d3NoteText, {\n  className: \"callout\",\n  note: { lineType: \"horizontal\" }\n})\n\nexport const d3CalloutElbow = customType(d3Callout, {\n  className: \"callout elbow\",\n  connector: { type: \"elbow\" }\n})\n\nexport const d3CalloutCurve = customType(d3Callout, {\n  className: \"callout curve\",\n  connector: { type: \"curve\" }\n})\n\nexport const d3Badge = customType(Type, {\n  className: \"badge\",\n  subject: { type: \"badge\" },\n  disable: [\"connector\", \"note\"]\n})\n\nexport const d3CalloutCircle = customType(d3NoteText, {\n  className: \"callout circle\",\n  subject: { type: \"circle\" },\n  note: { lineType: \"horizontal\" },\n  connector: { type: \"elbow\" }\n})\n\nexport const d3CalloutRect = customType(d3NoteText, {\n  className: \"callout rect\",\n  subject: { type: \"rect\" },\n  note: { lineType: \"horizontal\" },\n  connector: { type: \"elbow\" }\n})\n\nclass ThresholdMap extends d3Callout {\n  mapY(accessors) {\n    super.mapY(accessors)\n    const a = this.annotation\n    if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {\n      a.y = accessors.y(a.data)\n    }\n    if ((a.subject.x1 || a.subject.x2) && !a.x) {\n      a.x = a.subject.x1 || a.subject.x2\n    }\n  }\n\n  mapX(accessors) {\n    super.mapX(accessors)\n    const a = this.annotation\n    if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {\n      a.x = accessors.x(a.data)\n    }\n    if ((a.subject.y1 || a.subject.y2) && !a.y) {\n      a.y = a.subject.y1 || a.subject.y2\n    }\n  }\n}\n\nexport const d3XYThreshold = customType(ThresholdMap, {\n  className: \"callout xythreshold\",\n  subject: { type: \"threshold\" }\n})\n\nexport const newWithClass = (a, d, type, className, classID) => {\n  const group = a.selectAll(`${type}.${classID || className}`).data(d)\n  group\n    .enter()\n    .append(type)\n    .merge(group)\n    .attr(\"class\", className)\n\n  group.exit().remove()\n  return a\n}\n\nconst addHandlers = (dispatcher, annotation, { component, name }) => {\n  if (component) {\n    component\n      .on(\"mouseover.annotations\", () => {\n        dispatcher.call(`${name}over`, component, annotation)\n      })\n      .on(\"mouseout.annotations\", () =>\n        dispatcher.call(`${name}out`, component, annotation)\n      )\n      .on(\"click.annotations\", () =>\n        dispatcher.call(`${name}click`, component, annotation)\n      )\n  }\n}\n\n//Text wrapping code adapted from Mike Bostock\nconst wrap = (text, width, wrapSplitter, lineHeight = 1.2) => {\n  text.each(function() {\n    const text = select(this),\n      words = text\n        .text()\n        .split(wrapSplitter || /[ \\t\\r\\n]+/)\n        .reverse()\n        .filter(w => w !== \"\")\n    let word,\n      line = [],\n      tspan = text\n        .text(null)\n        .append(\"tspan\")\n        .attr(\"x\", 0)\n        .attr(\"dy\", 0.8 + \"em\")\n\n    while (word = words.pop()) {\n      line.push(word)\n      tspan.text(line.join(\" \"))\n      if (tspan.node().getComputedTextLength() > width && line.length > 1) {\n        line.pop()\n        tspan.text(line.join(\" \"))\n        line = [word]\n        tspan = text\n          .append(\"tspan\")\n          .attr(\"x\", 0)\n          .attr(\"dy\", lineHeight + \"em\")\n          .text(word)\n      }\n    }\n  })\n}\n\nconst bboxWithoutHandles = (selection, selector = \":not(.handle)\") => {\n  if (!selection) {\n    return { x: 0, y: 0, width: 0, height: 0 }\n  }\n\n  return selection\n    .selectAll(selector)\n    .nodes()\n    .reduce(\n      (p, c) => {\n        const bbox = c.getBBox()\n        p.x = Math.min(p.x, bbox.x)\n        p.y = Math.min(p.y, bbox.y)\n        p.width = Math.max(p.width, bbox.width)\n\n        const yOffset = c && c.attributes && c.attributes.y\n        p.height = Math.max(\n          p.height,\n          (yOffset && parseFloat(yOffset.value) || 0) + bbox.height\n        )\n        return p\n      },\n      { x: 0, y: 0, width: 0, height: 0 }\n    )\n}\n\nexport default {\n  Type,\n  d3Label,\n  d3Callout,\n  d3CalloutElbow,\n  d3CalloutCurve,\n  d3CalloutCircle,\n  d3CalloutRect,\n  d3XYThreshold,\n  d3Badge,\n  customType\n}\n","import Annotation from \"./Annotation\"\nimport AnnotationCollection from \"./AnnotationCollection\"\nimport { newWithClass, d3Callout } from \"./Types-d3\"\nimport { select } from \"d3-selection\"\nimport { dispatch } from \"d3-dispatch\"\n\nexport default function annotation() {\n  let annotations = [],\n    collection,\n    context, //TODO: add canvas functionality\n    disable = [],\n    accessors = {},\n    accessorsInverse = {},\n    editMode = false,\n    ids,\n    type = d3Callout,\n    textWrap,\n    notePadding,\n    annotationDispatcher = dispatch(\n      \"subjectover\",\n      \"subjectout\",\n      \"subjectclick\",\n      \"connectorover\",\n      \"connectorout\",\n      \"connectorclick\",\n      \"noteover\",\n      \"noteout\",\n      \"noteclick\",\n      \"dragend\",\n      \"dragstart\"\n    ),\n    sel\n\n  const annotation = function(selection) {\n    sel = selection\n    //TODO: check to see if this is still needed\n    if (!editMode) {\n      selection.selectAll(\"circle.handle\").remove()\n    }\n\n    const translatedAnnotations = annotations.map(a => {\n      if (!a.type) {\n        a.type = type\n      }\n      if (!a.disable) {\n        a.disable = disable\n      }\n      return new Annotation(a)\n    })\n\n    collection =\n      collection ||\n      new AnnotationCollection({\n        annotations: translatedAnnotations,\n        accessors,\n        accessorsInverse,\n        ids\n      })\n\n    const annotationG = selection.selectAll(\"g\").data([collection])\n    annotationG.enter().append(\"g\").attr(\"class\", `annotations`)\n\n    const group = selection.select(\"g.annotations\")\n    newWithClass(group, collection.annotations, \"g\", \"annotation\")\n\n    const annotation = group.selectAll(\"g.annotation\")\n\n    annotation.each(function(d) {\n      const a = select(this)\n\n      a.attr(\"class\", \"annotation\")\n\n      newWithClass(a, [d], \"g\", \"annotation-connector\")\n      newWithClass(a, [d], \"g\", \"annotation-subject\")\n      newWithClass(a, [d], \"g\", \"annotation-note\")\n      newWithClass(\n        a.select(\"g.annotation-note\"),\n        [d],\n        \"g\",\n        \"annotation-note-content\"\n      )\n      d.type =\n        d.type.toString() === \"[object Object]\"\n          ? d.type\n          : new d.type({\n            a,\n            annotation: d,\n            textWrap,\n            notePadding,\n            editMode,\n            dispatcher: annotationDispatcher,\n            accessors\n          })\n      d.type.draw()\n      d.type.drawText && d.type.drawText()\n    })\n  }\n\n  annotation.json = function() {\n    /* eslint-disable no-console */\n    console.log(\n      \"Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.\",\n      collection.json\n    )\n    /* eslint-enable no-console */\n    window.copy(\n      JSON.stringify(\n        collection.json.map(a => {\n          delete a.type\n          return a\n        })\n      )\n    )\n    return annotation\n  }\n\n  annotation.update = function() {\n    if (annotations && collection) {\n      annotations = collection.annotations.map(a => {\n        a.type.draw()\n        return a\n      })\n    }\n    return annotation\n  }\n\n  annotation.updateText = function() {\n    if (collection) {\n      collection.updateText(textWrap)\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n\n  annotation.updatedAccessors = function() {\n    collection.setPositionWithAccessors()\n    annotations = collection.annotations\n    return annotation\n  }\n\n  annotation.disable = function(_) {\n    if (!arguments.length) return disable\n    disable = _\n    if (collection) {\n      collection.updateDisable(disable)\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n\n  annotation.textWrap = function(_) {\n    if (!arguments.length) return textWrap\n    textWrap = _\n    if (collection) {\n      collection.updateTextWrap(textWrap)\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n\n  annotation.notePadding = function(_) {\n    if (!arguments.length) return notePadding\n    notePadding = _\n    if (collection) {\n      collection.updateNotePadding(notePadding)\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n  //todo think of how to handle when undefined is sent\n  annotation.type = function(_, settings) {\n    if (!arguments.length) return type\n    type = _\n    if (collection) {\n      collection.annotations.map(a => {\n        a.type.note &&\n          a.type.note.selectAll(\"*:not(.annotation-note-content)\").remove()\n        a.type.noteContent && a.type.noteContent.selectAll(\"*\").remove()\n        a.type.subject && a.type.subject.selectAll(\"*\").remove()\n        a.type.connector && a.type.connector.selectAll(\"*\").remove()\n        a.type.typeSettings = {}\n        a.type = type\n\n        a.subject = settings && settings.subject || a.subject\n        a.connector = settings && settings.connector || a.connector\n        a.note = settings && settings.note || a.note\n      })\n\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n\n  annotation.annotations = function(_) {\n    if (!arguments.length)\n      return collection && collection.annotations || annotations\n    annotations = _\n\n    if (collection && collection.annotations) {\n      const rerun = annotations.some(\n        d => !d.type || d.type.toString() !== \"[object Object]\"\n      )\n\n      if (rerun) {\n        collection = null\n        annotation(sel)\n      } else {\n        collection.annotations = annotations\n      }\n    }\n    return annotation\n  }\n\n  annotation.context = function(_) {\n    if (!arguments.length) return context\n    context = _\n    return annotation\n  }\n\n  annotation.accessors = function(_) {\n    if (!arguments.length) return accessors\n    accessors = _\n    return annotation\n  }\n\n  annotation.accessorsInverse = function(_) {\n    if (!arguments.length) return accessorsInverse\n    accessorsInverse = _\n    return annotation\n  }\n\n  annotation.ids = function(_) {\n    if (!arguments.length) return ids\n    ids = _\n    return annotation\n  }\n\n  annotation.editMode = function(_) {\n    if (!arguments.length) return editMode\n    editMode = _\n\n    if (sel) {\n      sel.selectAll(\"g.annotation\").classed(\"editable\", editMode)\n    }\n\n    if (collection) {\n      collection.editMode(editMode)\n      annotations = collection.annotations\n    }\n    return annotation\n  }\n\n  annotation.collection = function(_) {\n    if (!arguments.length) return collection\n    collection = _\n    return annotation\n  }\n\n  annotation.on = function() {\n    const value = annotationDispatcher.on.apply(annotationDispatcher, arguments)\n    return value === annotationDispatcher ? annotation : value\n  }\n\n  return annotation\n}\n","import annotation from './src/Adapter-d3'\nimport { Type, d3Label, d3Callout, d3CalloutCurve, d3CalloutElbow, d3CalloutCircle, \n d3CalloutRect, d3XYThreshold, d3Badge, customType } from './src/Types-d3'\n\nexport {\n  annotation,\n  Type as annotationTypeBase ,\n  d3Label as annotationLabel ,\n  d3Callout as annotationCallout ,\n  d3CalloutCurve as annotationCalloutCurve ,\n  d3CalloutElbow as annotationCalloutElbow ,\n  d3CalloutCircle as annotationCalloutCircle ,\n  d3CalloutRect as annotationCalloutRect ,\n  d3XYThreshold as annotationXYThreshold ,\n  d3Badge as annotationBadge ,\n  customType as annotationCustomType \n}\n\nexport default {\n  annotation,\n  annotationTypeBase : Type,\n  annotationLabel : d3Label,\n  annotationCallout : d3Callout,\n  annotationCalloutCurve : d3CalloutCurve,\n  annotationCalloutElbow : d3CalloutElbow,\n  annotationCalloutCircle : d3CalloutCircle,\n  annotationCalloutRect : d3CalloutRect,\n  annotationXYThreshold : d3XYThreshold,\n  annotationBadge : d3Badge,\n  annotationCustomType : customType\n}"]},"metadata":{},"sourceType":"module"}